{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p>PyBrook - a real-time cloud computing framework for the Internet of Things. PyBrook enables users to define complex data processing models declaratively using the Python programming language. The framework also provides a generic web interface that presents the collected data in real-time.</p> <p>PyBrook aims to make the development of real-time data processing services as easy as possible by utilising powerful  mechanisms of the Python programming language and modern concepts like hot-reloading or deploying software in Linux Containers.</p> <p>A simple <code>docker-compose up</code> is enough to start playing with the framework.</p>"},{"location":"index.html#run-demo-with-docker","title":"Run demo with Docker","text":"<p>It is recommended to use <code>docker-compose</code> for learning (you can use the <code>docker-compose.yml</code> from the project repository:</p> <pre><code>docker-compose up\n</code></pre> <p>This command will start all the services, including Redis with Redis Gears enabled.</p> <p>The following services will be available:</p> <ul> <li>OpenAPI docs (ReDoc): http://localhost:8000/redoc </li> <li>OpenAPI docs (Swagger UI): http://localhost:8000/docs </li> <li>PyBrook frontend: http://localhost:8000/panel </li> <li>Locust panel for load testing: http://localhost:8089</li> </ul> <p>You should probably visit the Locust panel first and start sending some reports.</p>"},{"location":"index.html#using-your-own-model","title":"Using your own model","text":"<p>The configured model is <code>pybrook.examples.demo</code>, but replacing it with your own is very easy. First, you have to save your custom model somewhere.  For now, you can just copy the source of <code>pybrook.examples.demo</code> (attached below) and save it as <code>mymodel.py</code> in your working directory.</p> Source of <code>pybrook.examples.demo</code> <pre><code>from datetime import datetime\nfrom math import atan2, degrees\nfrom typing import Optional, Sequence\n\nfrom pybrook.models import (\n    InReport,\n    OutReport,\n    PyBrook,\n    ReportField,\n    dependency,\n    historical_dependency,\n)\n\nbrook = PyBrook('redis://localhost')\napp = brook.app\n\n\n@brook.input('ztm-report', id_field='vehicle_number')\nclass ZTMReport(InReport):\n    vehicle_number: int\n    time: datetime\n    lat: float\n    lon: float\n    brigade: str\n    line: str\n\n\n@brook.output('location-report')\nclass LocationReport(OutReport):\n    vehicle_number = ReportField(ZTMReport.vehicle_number)\n    lat = ReportField(ZTMReport.lat)\n    lon = ReportField(ZTMReport.lon)\n    line = ReportField(ZTMReport.line)\n    time = ReportField(ZTMReport.time)\n    brigade = ReportField(ZTMReport.brigade)\n\n\n@brook.artificial_field()\ndef direction(lat_history: Sequence[float] = historical_dependency(\n    ZTMReport.lat, history_length=1),\n                    lon_history: Sequence[float] = historical_dependency(\n                        ZTMReport.lon, history_length=1),\n                    lat: float = dependency(ZTMReport.lat),\n                    lon: float = dependency(ZTMReport.lon)) -&gt; Optional[float]:\n    prev_lat, = lat_history\n    prev_lon, = lon_history\n    if prev_lat and prev_lon:\n        return degrees(atan2(lon - prev_lon, lat - prev_lat))\n    else:\n        return None\n\n\n@brook.output('direction-report')\nclass DirectionReport(OutReport):\n    direction = ReportField(direction)\n\n\n@brook.artificial_field()\nasync def counter(prev_values: Sequence[int] = historical_dependency(\n    'counter', history_length=1),\n                  time: datetime = dependency(ZTMReport.time)) -&gt; int:\n    prev_value, = prev_values\n    if prev_value is None:\n        prev_value = -1\n    prev_value += 1\n    return prev_value\n\n\n@brook.output('counter-report')\nclass CounterReport(OutReport):\n    counter = ReportField(counter)\n\n\nbrook.set_meta(latitude_field=LocationReport.lat,\n               longitude_field=LocationReport.lon,\n               time_field=LocationReport.time,\n               group_field=LocationReport.line,\n               direction_field=DirectionReport.direction)\n\nif __name__ == '__main__':\n    brook.run()\n</code></pre> <p>After creating <code>mymodel.py</code>, you should add it to the <code>api</code> and <code>worker</code> containers, using a Docker volume. To make PyBrook use <code>mymodel</code> instead of <code>pybrook.examples.demo</code>, you should also alter the arguments passed to <code>gunicorn</code> and <code>pybrook</code>.  You can simply add it to the default <code>docker-compose.yml</code>:</p> <pre><code>services:\napi:\nimage: pybrook:latest\nbuild:\ncontext: .\nenvironment:\nREDIS_URL: redis://redis\nports:\n- 8000:8000\nvolumes:\n- ./mymodel.py:/src/mymodel.py\ncommand: gunicorn mymodel:app -w 4 -k uvicorn.workers.UvicornWorker -b 0.0.0.0:8000\nworker:\nimage: pybrook:latest\ndepends_on:\n- api\nenvironment:\nREDIS_URL: redis://redis\nDEFAULT_WORKERS: 8\nvolumes:\n- ./mymodel.py:/src/mymodel.py\ncommand: pybrook mymodel:brook\nlocust:\nimage: pybrook:latest\ndepends_on:\n- api\nports:\n- 8089:8089\ncommand: locust -H http://api:8000\nredis:\nimage: redislabs/redisgears:latest\n</code></pre> <p>Then run <code>docker-compose up --build</code> again, to start PyBrook - this time using your own model.</p>"},{"location":"index.html#setup-development","title":"Setup &amp; Development","text":"<p>You can install the PyBrook from PyPi using <code>pip</code>:</p> <pre><code>pip install pybrook\n</code></pre>"},{"location":"index.html#running-all-services-manually-without-docker","title":"Running all services manually, without Docker","text":"<p>To run the <code>pybrook.examples.demo</code> model, you have to start all the required services manually:</p> <pre><code># Redis + Redis Gears\ndocker run --net=host -d redislabs/redisgears\n# HTTP API based on pybrook.examples.demo - uvicorn\nuvicorn pybrook.examples.demo:app --reload  # PyBrook workers based on pybrook.examples.demo \npybrook pybrook.examples.demo:brook   # Locust - load testing\nlocust -H http://localhost:8000\n</code></pre>"},{"location":"index.html#contributing","title":"Contributing","text":"<p>PyBrook uses poetry for dependency management. To install all its development dependencies, simply run this command:</p> <pre><code>poetry install\n</code></pre>"},{"location":"index.html#tests","title":"Tests","text":"<pre><code>make test\n</code></pre>"},{"location":"index.html#code-quality","title":"Code quality","text":"<p>The source code of PyBrook is formatted using yapf and isort. To run them with the correct settings, use the following command:</p> <pre><code>make format\n</code></pre> <p>PyBrook uses <code>mypy</code> for type checking and <code>flake8</code> for linting. Use the following command to run them with the appropriate settings:</p> <pre><code>make lint\n</code></pre>"},{"location":"reference/__main__.html","title":"__main__","text":"<p>PyBrook CLI entrypoint.</p>"},{"location":"reference/__main__.html#pybrook.__main__.ModelChangeEventHandler","title":"<code>ModelChangeEventHandler</code>","text":"<p>         Bases: <code>FileSystemEventHandler</code></p> <p>Handles model hot-reloading.</p> Source code in <code>pybrook/__main__.py</code> <pre><code>class ModelChangeEventHandler(FileSystemEventHandler):\n\"\"\"\n    Handles model hot-reloading.\n    \"\"\"\n    def __init__(self, brook):\n\"\"\"\n\n        Args:\n            brook: A PyBrook instance.\n        \"\"\"\n        self.brook = brook\n        self.modified = False\n\n    def on_modified(self, event: Union[DirModifiedEvent, FileModifiedEvent]):\n\"\"\"\n\n        Args:\n            event: Event representing file/directory modification.\n        \"\"\"\n        logger.info('File change detected, reloading...')\n        self.modified = True\n        self.brook.terminate()\n</code></pre>"},{"location":"reference/__main__.html#pybrook.__main__.ModelChangeEventHandler.brook","title":"<code>brook = brook</code>  <code>instance-attribute</code>","text":""},{"location":"reference/__main__.html#pybrook.__main__.ModelChangeEventHandler.modified","title":"<code>modified = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/__main__.html#pybrook.__main__.ModelChangeEventHandler.__init__","title":"<code>__init__(brook)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>brook</code> <p>A PyBrook instance.</p> required Source code in <code>pybrook/__main__.py</code> <pre><code>def __init__(self, brook):\n\"\"\"\n\n    Args:\n        brook: A PyBrook instance.\n    \"\"\"\n    self.brook = brook\n    self.modified = False\n</code></pre>"},{"location":"reference/__main__.html#pybrook.__main__.ModelChangeEventHandler.on_modified","title":"<code>on_modified(event)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>event</code> <code>Union[DirModifiedEvent, FileModifiedEvent]</code> <p>Event representing file/directory modification.</p> required Source code in <code>pybrook/__main__.py</code> <pre><code>def on_modified(self, event: Union[DirModifiedEvent, FileModifiedEvent]):\n\"\"\"\n\n    Args:\n        event: Event representing file/directory modification.\n    \"\"\"\n    logger.info('File change detected, reloading...')\n    self.modified = True\n    self.brook.terminate()\n</code></pre>"},{"location":"reference/__main__.html#pybrook.__main__.add_consumer_args","title":"<code>add_consumer_args(parser, consumers)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>parser</code> <code>argparse.ArgumentParser</code> <p>The main argument parser.</p> required <code>consumers</code> <code>List[BaseStreamConsumer]</code> <p>List of consumers to generate CLI options for.</p> required <p>Returns:</p> Type Description <code>Dict[str, ConsumerConfig]</code> <p>A dictionary of consumer configs filled with defaults. Consumer group names are used as keys.</p> Source code in <code>pybrook/__main__.py</code> <pre><code>def add_consumer_args(\n        parser: argparse.ArgumentParser,\n        consumers: List[BaseStreamConsumer]) -&gt; Dict[str, ConsumerConfig]:\n\"\"\"\n\n    Args:\n        parser: The main argument parser.\n        consumers: List of consumers to generate CLI options for.\n\n    Returns:\n        A dictionary of consumer configs filled with defaults. Consumer group names are used as keys.\n\n    \"\"\"\n    workers_config = {}\n    for c in consumers:\n        if not isinstance(c, GearsStreamConsumer):\n            consumer_config = ConsumerConfig()\n            parser.add_argument(\n                f'--{c.consumer_group_name}-workers',\n                type=int,\n                help='(default: %(default)s)',  # noqa: WPS323\n                default=consumer_config.workers)\n            workers_config[c.consumer_group_name] = consumer_config\n    return workers_config\n</code></pre>"},{"location":"reference/__main__.html#pybrook.__main__.main","title":"<code>main()</code>","text":"<p>CLI Entrypoint.</p> <p>Starts PyBrook workers.</p> <p>Examples:</p> <pre><code>\u276f pybrook pybrook.examples.demo:brook --help\nusage: pybrook [-h]\n[--location-report:dr-workers LOCATION_REPORT:DR_WORKERS]\n[--direction-report:dr-workers DIRECTION_REPORT:DR_WORKERS]\n[--brigade-report:dr-workers BRIGADE_REPORT:DR_WORKERS]\n[--direction:dr-workers DIRECTION:DR_WORKERS]\n[--direction:fg-workers DIRECTION:FG_WORKERS]\nAPP\n\npositional arguments:\n  APP\n\noptions:\n  -h, --help\n  --location-report:dr-workers LOCATION_REPORT:DR_WORKERS\n                        (default: 4)\n--direction-report:dr-workers DIRECTION_REPORT:DR_WORKERS\n                        (default: 4)\n--brigade-report:dr-workers BRIGADE_REPORT:DR_WORKERS\n                        (default: 4)\n--direction:dr-workers DIRECTION:DR_WORKERS\n                        (default: 4)\n--direction:fg-workers DIRECTION:FG_WORKERS\n                        (default: 4)\n</code></pre> Source code in <code>pybrook/__main__.py</code> <pre><code>def main():\n\"\"\"\n    CLI Entrypoint.\n\n    Starts PyBrook workers.\n\n    Examples:\n\n        ```bash\n        \u276f pybrook pybrook.examples.demo:brook --help\n        usage: pybrook [-h]\n               [--location-report:dr-workers LOCATION_REPORT:DR_WORKERS]\n               [--direction-report:dr-workers DIRECTION_REPORT:DR_WORKERS]\n               [--brigade-report:dr-workers BRIGADE_REPORT:DR_WORKERS]\n               [--direction:dr-workers DIRECTION:DR_WORKERS]\n               [--direction:fg-workers DIRECTION:FG_WORKERS]\n               APP\n\n        positional arguments:\n          APP\n\n        options:\n          -h, --help\n          --location-report:dr-workers LOCATION_REPORT:DR_WORKERS\n                                (default: 4)\n          --direction-report:dr-workers DIRECTION_REPORT:DR_WORKERS\n                                (default: 4)\n          --brigade-report:dr-workers BRIGADE_REPORT:DR_WORKERS\n                                (default: 4)\n          --direction:dr-workers DIRECTION:DR_WORKERS\n                                (default: 4)\n          --direction:fg-workers DIRECTION:FG_WORKERS\n                                (default: 4)\n\n        ```\n    \"\"\"\n\n    parser = argparse.ArgumentParser(add_help=False)\n    parser.add_argument('-h', '--help', action='store_true')\n    parser.add_argument('APP', nargs=1)\n    args: argparse.Namespace\n    unknown: List[str]\n    args, unknown = parser.parse_known_args()\n    app_arg = args.APP[-1].split(':') if args.APP else None\n    if not app_arg and args.help:\n        parser.print_help()\n        return\n    model_module = import_module(app_arg[0])\n    modified = True\n    while modified:\n        brook: PyBrook = getattr(\n            model_module,\n            app_arg[1]) if len(app_arg) &gt; 1 else model_module.brook\n        brook.process_model()\n        workers_config = add_consumer_args(parser, brook.consumers)\n        args = parser.parse_args()\n        if args.help:\n            parser.print_help()\n            return\n        update_workers_config(args, workers_config)\n        handler = ModelChangeEventHandler(brook)\n        observer = Observer()\n        observer.schedule(handler, model_module.__file__)  # noqa: WPS609\n        observer.start()\n        brook.run(config=workers_config)\n        observer.stop()\n        observer.join()\n        reload(model_module)\n        modified = handler.modified\n</code></pre>"},{"location":"reference/__main__.html#pybrook.__main__.update_workers_config","title":"<code>update_workers_config(args, workers_config)</code>","text":"<p>Updates <code>workers_config</code> with settings loaded from argparse arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>argparse.Namespace</code> <p>An argparse <code>Namespace</code></p> required <code>workers_config</code> <code>Dict[str, ConsumerConfig]</code> <p>A dictionary of consumer configs to update using settings loaded from the <code>args</code> argument.</p> required Source code in <code>pybrook/__main__.py</code> <pre><code>def update_workers_config(args: argparse.Namespace,\n                          workers_config: Dict[str, ConsumerConfig]):\n\"\"\"\n    Updates `workers_config` with settings loaded from argparse arguments.\n\n    Args:\n        args: An argparse `Namespace`\n        workers_config:  A dictionary of consumer configs to update using settings loaded from the `args` argument.\n\n    Returns:\n\n    \"\"\"\n    for c in workers_config.keys():\n        for arg in ('workers', ):\n            arg_name: str = c.replace('-', '_') + '_' + arg\n            setattr(workers_config[c], arg, getattr(args, arg_name))\n</code></pre>"},{"location":"reference/config.html","title":"config","text":""},{"location":"reference/config.html#pybrook.config.ARTIFICIAL_NAMESPACE","title":"<code>ARTIFICIAL_NAMESPACE = config('ARTIFICIAL_NAMESPACE', str, default='artificial')</code>  <code>module-attribute</code>","text":""},{"location":"reference/config.html#pybrook.config.DEFAULT_WORKERS","title":"<code>DEFAULT_WORKERS = config('DEFAULT_WORKERS', int, default=4)</code>  <code>module-attribute</code>","text":""},{"location":"reference/config.html#pybrook.config.MSG_ID_FIELD","title":"<code>MSG_ID_FIELD = config('MSG_ID_FIELD', str, default=f'{SPECIAL_CHAR}_msg_id')</code>  <code>module-attribute</code>","text":""},{"location":"reference/config.html#pybrook.config.REDIS_URI","title":"<code>REDIS_URI = config('REDIS_URI', str, default='redis://localhost')</code>  <code>module-attribute</code>","text":""},{"location":"reference/config.html#pybrook.config.SPECIAL_CHAR","title":"<code>SPECIAL_CHAR = config('SPECIAL_CHAR', str, default=':')</code>  <code>module-attribute</code>","text":""},{"location":"reference/config.html#pybrook.config.WEBSOCKET_PING_INTERVAL","title":"<code>WEBSOCKET_PING_INTERVAL = config('WEBSOCKET_PING_INTERVAL', int, default=30)</code>  <code>module-attribute</code>","text":""},{"location":"reference/config.html#pybrook.config.WEBSOCKET_WAIT_TIME","title":"<code>WEBSOCKET_WAIT_TIME = config('WEBSOCKET_WAIT_TIME', float, default=0.01)</code>  <code>module-attribute</code>","text":""},{"location":"reference/config.html#pybrook.config.WEBSOCKET_XREAD_BLOCK","title":"<code>WEBSOCKET_XREAD_BLOCK = config('WEBSOCKET_XREAD_BLOCK', int, default=100)</code>  <code>module-attribute</code>","text":""},{"location":"reference/config.html#pybrook.config.WEBSOCKET_XREAD_COUNT","title":"<code>WEBSOCKET_XREAD_COUNT = config('WEBSOCKET_XREAD_COUNT', int, default=1000)</code>  <code>module-attribute</code>","text":""},{"location":"reference/config.html#pybrook.config.config","title":"<code>config = Config()</code>  <code>module-attribute</code>","text":""},{"location":"reference/encoding.html","title":"encoding","text":""},{"location":"reference/encoding.html#pybrook.encoding.decode_stream_message","title":"<code>decode_stream_message(data)</code>","text":"Source code in <code>pybrook/encoding.py</code> <pre><code>def decode_stream_message(data: Dict[str, str]):\n    return {k: decode_value(v) for k, v in data.items()}\n</code></pre>"},{"location":"reference/encoding.html#pybrook.encoding.decode_value","title":"<code>decode_value(v)</code>","text":"Source code in <code>pybrook/encoding.py</code> <pre><code>def decode_value(v: Any):\n    return orjson.loads(v)\n</code></pre>"},{"location":"reference/encoding.html#pybrook.encoding.encode_stream_message","title":"<code>encode_stream_message(data)</code>","text":"Source code in <code>pybrook/encoding.py</code> <pre><code>def encode_stream_message(data: Dict[str, Any]):\n    return {k: encode_value(v) for k, v in data.items()}\n</code></pre>"},{"location":"reference/encoding.html#pybrook.encoding.encode_value","title":"<code>encode_value(v)</code>","text":"Source code in <code>pybrook/encoding.py</code> <pre><code>def encode_value(v: Any):\n    return orjson.dumps(v)\n</code></pre>"},{"location":"reference/models.html","title":"models","text":"<p>This module is responsible for parsing report processing models.</p> <p>It is the core of PyBrook.</p>"},{"location":"reference/models.html#pybrook.models.DTYPE","title":"<code>DTYPE = TypeVar('DTYPE')</code>  <code>module-attribute</code>","text":"<p>A TypeVar used by dependency and historal_dependency, enable mypy to detect issues with dependency types.</p>"},{"location":"reference/models.html#pybrook.models.DependencySource","title":"<code>DependencySource = Union['SourceField', Type[aioredis.Redis], Type[redis.Redis]]</code>  <code>module-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.TI","title":"<code>TI = TypeVar('TI', bound=Type[InReport])</code>  <code>module-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.TO","title":"<code>TO = TypeVar('TO', bound=Type[OutReport])</code>  <code>module-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.TOPT","title":"<code>TOPT = TypeVar('TOPT')</code>  <code>module-attribute</code>","text":"<p>A TypeVar used by OptionsMixin, to define the type of the Options.</p>"},{"location":"reference/models.html#pybrook.models.ArtificialField","title":"<code>ArtificialField</code>","text":"<p>         Bases: <code>SourceField</code>, <code>Registrable</code>, <code>ConsumerGenerator</code></p> Source code in <code>pybrook/models.py</code> <pre><code>class ArtificialField(SourceField, Registrable, ConsumerGenerator):\n    def __init__(self, calculate: Callable, name: str = None):\n        annotations = get_type_hints(calculate)\n        try:\n            value_type = annotations.pop('return')\n        except KeyError:\n            raise ValueError(\n                f'Please specify return value for {calculate.__name__}')\n        super().__init__(field_name=(name or calculate.__name__),\n                         value_type=value_type)\n        self.args: inspect.Signature = inspect.signature(calculate)\n        self.is_coro: bool = inspect.iscoroutinefunction(calculate)\n        self.dependencies: Dict[str, Dependency] = {\n            arg_name: arg.default\n            for arg_name, arg in self.args.parameters.items()\n        }\n        all_defaults_are_deps = all(\n            isinstance(d, Dependency) for k, d in self.dependencies.items())\n        if not all_defaults_are_deps:\n            raise RuntimeError(\n                f'Artificial field \"{self.field_name}\" has default values'\n                f' which do not subclass Dependency.')\n        self.calculate = calculate\n\n    def __call__(self, *args, **kwargs):\n        return self.calculate(*args, **kwargs)\n\n    @property\n    def regular_dependencies(self) -&gt; Dict[str, Dependency]:\n        return {\n            k: d\n            for k, d in self.dependencies.items()\n            if not isinstance(d, HistoricalDependency)\n        }\n\n    @property\n    def historical_dependencies(self) -&gt; Dict[str, HistoricalDependency]:\n        return {\n            k: d\n            for k, d in self.dependencies.items()\n            if isinstance(d, HistoricalDependency)\n        }\n\n    def on_registered(self, model: 'PyBrook'):\n        for dep in self.dependencies.values():\n            dep.on_registered(model)\n\n    def gen_consumers(self, model: 'PyBrook'):  # type: ignore\n        dependency_resolver = DependencyResolver(\n            redis_url=model.redis_url,\n            output_stream_name=(f'{SPECIAL_CHAR}{self.field_name}'\n                                f'{SPECIAL_CHAR}deps'),\n            dependencies=[\n                DependencyResolver.Dep(src_stream=dep.src_field.stream_name,\n                                       src_key=dep.src_field.field_name,\n                                       dst_key=dep_key)\n                for dep_key, dep in self.regular_dependencies.items()\n                if dep.src_field\n            ],\n            historical_dependencies=[\n                DependencyResolver.HistoricalDep(\n                    src_stream=dep.src_field.stream_name,\n                    src_key=dep.src_field.field_name,\n                    dst_key=dep_key,\n                    history_length=dep.history_length)\n                for dep_key, dep in self.historical_dependencies.items()\n                if dep.src_field\n            ],\n            resolver_name=self.field_name)\n        model.add_consumer(dependency_resolver)\n\n        field_generator_deps = [\n            BaseFieldGenerator.Dep(name=dep_name, value_type=dep.value_type)\n            for dep_name, dep in self.dependencies.items()\n            if dep.src_field\n        ]\n\n        generator_class: Type[\n            BaseFieldGenerator] = AsyncFieldGenerator if self.is_coro else SyncFieldGenerator\n\n        field_generator = generator_class(\n            redis_url=model.redis_url,\n            dependency_stream=dependency_resolver.output_stream_name,\n            field_name=self.field_name,\n            generator=self.calculate,\n            dependencies=field_generator_deps,\n            redis_deps=[\n                key for key, dep in self.dependencies.items()\n                if (dep.is_aioredis and self.is_coro) or dep.is_redis\n            ])\n\n        model.add_consumer(field_generator)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.ArtificialField.args","title":"<code>args: inspect.Signature = inspect.signature(calculate)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.ArtificialField.calculate","title":"<code>calculate = calculate</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.ArtificialField.dependencies","title":"<code>dependencies: Dict[str, Dependency] = {arg_name: arg.default for (arg_name, arg) in self.args.parameters.items()}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.ArtificialField.historical_dependencies","title":"<code>historical_dependencies: Dict[str, HistoricalDependency]</code>  <code>property</code>","text":""},{"location":"reference/models.html#pybrook.models.ArtificialField.is_coro","title":"<code>is_coro: bool = inspect.iscoroutinefunction(calculate)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.ArtificialField.regular_dependencies","title":"<code>regular_dependencies: Dict[str, Dependency]</code>  <code>property</code>","text":""},{"location":"reference/models.html#pybrook.models.ArtificialField.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __call__(self, *args, **kwargs):\n    return self.calculate(*args, **kwargs)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.ArtificialField.__init__","title":"<code>__init__(calculate, name=None)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __init__(self, calculate: Callable, name: str = None):\n    annotations = get_type_hints(calculate)\n    try:\n        value_type = annotations.pop('return')\n    except KeyError:\n        raise ValueError(\n            f'Please specify return value for {calculate.__name__}')\n    super().__init__(field_name=(name or calculate.__name__),\n                     value_type=value_type)\n    self.args: inspect.Signature = inspect.signature(calculate)\n    self.is_coro: bool = inspect.iscoroutinefunction(calculate)\n    self.dependencies: Dict[str, Dependency] = {\n        arg_name: arg.default\n        for arg_name, arg in self.args.parameters.items()\n    }\n    all_defaults_are_deps = all(\n        isinstance(d, Dependency) for k, d in self.dependencies.items())\n    if not all_defaults_are_deps:\n        raise RuntimeError(\n            f'Artificial field \"{self.field_name}\" has default values'\n            f' which do not subclass Dependency.')\n    self.calculate = calculate\n</code></pre>"},{"location":"reference/models.html#pybrook.models.ArtificialField.gen_consumers","title":"<code>gen_consumers(model)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def gen_consumers(self, model: 'PyBrook'):  # type: ignore\n    dependency_resolver = DependencyResolver(\n        redis_url=model.redis_url,\n        output_stream_name=(f'{SPECIAL_CHAR}{self.field_name}'\n                            f'{SPECIAL_CHAR}deps'),\n        dependencies=[\n            DependencyResolver.Dep(src_stream=dep.src_field.stream_name,\n                                   src_key=dep.src_field.field_name,\n                                   dst_key=dep_key)\n            for dep_key, dep in self.regular_dependencies.items()\n            if dep.src_field\n        ],\n        historical_dependencies=[\n            DependencyResolver.HistoricalDep(\n                src_stream=dep.src_field.stream_name,\n                src_key=dep.src_field.field_name,\n                dst_key=dep_key,\n                history_length=dep.history_length)\n            for dep_key, dep in self.historical_dependencies.items()\n            if dep.src_field\n        ],\n        resolver_name=self.field_name)\n    model.add_consumer(dependency_resolver)\n\n    field_generator_deps = [\n        BaseFieldGenerator.Dep(name=dep_name, value_type=dep.value_type)\n        for dep_name, dep in self.dependencies.items()\n        if dep.src_field\n    ]\n\n    generator_class: Type[\n        BaseFieldGenerator] = AsyncFieldGenerator if self.is_coro else SyncFieldGenerator\n\n    field_generator = generator_class(\n        redis_url=model.redis_url,\n        dependency_stream=dependency_resolver.output_stream_name,\n        field_name=self.field_name,\n        generator=self.calculate,\n        dependencies=field_generator_deps,\n        redis_deps=[\n            key for key, dep in self.dependencies.items()\n            if (dep.is_aioredis and self.is_coro) or dep.is_redis\n        ])\n\n    model.add_consumer(field_generator)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.ArtificialField.on_registered","title":"<code>on_registered(model)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def on_registered(self, model: 'PyBrook'):\n    for dep in self.dependencies.values():\n        dep.on_registered(model)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.ConsumerGenerator","title":"<code>ConsumerGenerator</code>","text":"<p>An interface describing objects that can generate stream consumers/producers.</p> Source code in <code>pybrook/models.py</code> <pre><code>class ConsumerGenerator:\n\"\"\"\n    An interface describing objects that can generate stream consumers/producers.\n    \"\"\"\n    @classmethod\n    def gen_consumers(cls, model: 'PyBrook'):\n\"\"\"\n        Implementations of this method should add consumers to the [PyBrook][pybrook.models.PyBrook] instance passed as `model`.\n\n        Args:\n            model: The PyBrook instance processed.\n\n        Raises:\n            NotImplementedError: When used directly.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/models.html#pybrook.models.ConsumerGenerator.gen_consumers","title":"<code>gen_consumers(model)</code>  <code>classmethod</code>","text":"<p>Implementations of this method should add consumers to the PyBrook instance passed as <code>model</code>.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>PyBrook</code> <p>The PyBrook instance processed.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>When used directly.</p> Source code in <code>pybrook/models.py</code> <pre><code>@classmethod\ndef gen_consumers(cls, model: 'PyBrook'):\n\"\"\"\n    Implementations of this method should add consumers to the [PyBrook][pybrook.models.PyBrook] instance passed as `model`.\n\n    Args:\n        model: The PyBrook instance processed.\n\n    Raises:\n        NotImplementedError: When used directly.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/models.html#pybrook.models.Dependency","title":"<code>Dependency</code>","text":"<p>         Bases: <code>Registrable</code></p> <p>This class represents a dependency of an ArtificialField.</p> <p>In theory, it can be used directly as an argument default of a calculation function, but it is recommended to use the dependency callable, which provides mypy compatibility instead.</p> Source code in <code>pybrook/models.py</code> <pre><code>class Dependency(Registrable):\n\"\"\"\n    This class represents a dependency of an [ArtificialField][pybrook.models.ArtificialField].\n\n    In theory, it can be used directly as an argument default of a calculation function,\n    but it is recommended to use the [dependency][pybrook.models.dependency] callable,\n    which provides mypy compatibility instead.\n    \"\"\"\n    def __init__(self, src: DependencySource):\n\"\"\"\n        See [dependency][pybrook.models.dependency].\n        \"\"\"\n        self.is_aioredis: bool = False\n        self.is_redis: bool = False\n        self.src_field: Optional[SourceField] = self.validate_source_field(src)\n        self.is_historical = False\n\n    @property\n    def value_type(self):\n\"\"\"Value type of the source field.\"\"\"\n        return self.src_field.value_type\n\n    def validate_source_field(self, src: DependencySource):\n        self.is_aioredis = type(src) == type and issubclass(  # noqa: WPS516\n            src, aioredis.Redis)\n        self.is_redis = type(src) == type and issubclass(  # noqa: WPS516\n            src, redis.Redis)\n        if isinstance(src, SourceField):\n            return src\n        elif not (self.is_aioredis or self.is_redis):\n            raise ValueError(\n                f'{src} is not an instance of SourceField or a Redis class')\n\n    def on_registered(self, model: 'PyBrook'):\n\"\"\"\n        Artificial fields can be evaluated lazily, that's why this is required.\n\n        Args:\n            model: model at which the field has been registered\n\n        Raises:\n            ValueError: when src_field is not an ArtificialField instance\n        \"\"\"\n        if isinstance(self.src_field, str):\n            try:\n                self.src_field = model.artificial_fields[self.src_field]\n            except KeyError as e:\n                raise ValueError(\n                    f'Lazy evaluation is only supported for artificial fields,'\n                    f' and {self.src_field} is not one of these.') from e\n\n    def __repr__(self):\n        if self.is_aioredis:\n            return '&lt;Dependency aioredis&gt;'\n        if self.is_redis:\n            return '&lt;Dependency redis&gt;'\n        return f'&lt;Dependency src_field={self.src_field}&gt;'\n</code></pre>"},{"location":"reference/models.html#pybrook.models.Dependency.is_aioredis","title":"<code>is_aioredis: bool = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.Dependency.is_historical","title":"<code>is_historical = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.Dependency.is_redis","title":"<code>is_redis: bool = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.Dependency.src_field","title":"<code>src_field: Optional[SourceField] = self.validate_source_field(src)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.Dependency.value_type","title":"<code>value_type</code>  <code>property</code>","text":"<p>Value type of the source field.</p>"},{"location":"reference/models.html#pybrook.models.Dependency.__init__","title":"<code>__init__(src)</code>","text":"<p>See dependency.</p> Source code in <code>pybrook/models.py</code> <pre><code>def __init__(self, src: DependencySource):\n\"\"\"\n    See [dependency][pybrook.models.dependency].\n    \"\"\"\n    self.is_aioredis: bool = False\n    self.is_redis: bool = False\n    self.src_field: Optional[SourceField] = self.validate_source_field(src)\n    self.is_historical = False\n</code></pre>"},{"location":"reference/models.html#pybrook.models.Dependency.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __repr__(self):\n    if self.is_aioredis:\n        return '&lt;Dependency aioredis&gt;'\n    if self.is_redis:\n        return '&lt;Dependency redis&gt;'\n    return f'&lt;Dependency src_field={self.src_field}&gt;'\n</code></pre>"},{"location":"reference/models.html#pybrook.models.Dependency.on_registered","title":"<code>on_registered(model)</code>","text":"<p>Artificial fields can be evaluated lazily, that's why this is required.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>PyBrook</code> <p>model at which the field has been registered</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>when src_field is not an ArtificialField instance</p> Source code in <code>pybrook/models.py</code> <pre><code>def on_registered(self, model: 'PyBrook'):\n\"\"\"\n    Artificial fields can be evaluated lazily, that's why this is required.\n\n    Args:\n        model: model at which the field has been registered\n\n    Raises:\n        ValueError: when src_field is not an ArtificialField instance\n    \"\"\"\n    if isinstance(self.src_field, str):\n        try:\n            self.src_field = model.artificial_fields[self.src_field]\n        except KeyError as e:\n            raise ValueError(\n                f'Lazy evaluation is only supported for artificial fields,'\n                f' and {self.src_field} is not one of these.') from e\n</code></pre>"},{"location":"reference/models.html#pybrook.models.Dependency.validate_source_field","title":"<code>validate_source_field(src)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def validate_source_field(self, src: DependencySource):\n    self.is_aioredis = type(src) == type and issubclass(  # noqa: WPS516\n        src, aioredis.Redis)\n    self.is_redis = type(src) == type and issubclass(  # noqa: WPS516\n        src, redis.Redis)\n    if isinstance(src, SourceField):\n        return src\n    elif not (self.is_aioredis or self.is_redis):\n        raise ValueError(\n            f'{src} is not an instance of SourceField or a Redis class')\n</code></pre>"},{"location":"reference/models.html#pybrook.models.HistoricalDependency","title":"<code>HistoricalDependency</code>","text":"<p>         Bases: <code>Dependency</code></p> <p>This class represents a historical dependency of an ArtificialField.</p> <p>In theory, it can be used directly as an argument default of a calculation function, but it is recommended to use the historical_dependency callable, which provides mypy compatibility instead.</p> Source code in <code>pybrook/models.py</code> <pre><code>class HistoricalDependency(Dependency):\n\"\"\"\n    This class represents a historical dependency of an [ArtificialField][pybrook.models.ArtificialField].\n\n    In theory, it can be used directly as an argument default of a calculation function,\n    but it is recommended to use the [historical_dependency][pybrook.models.historical_dependency] callable,\n    which provides mypy compatibility instead.\n    \"\"\"\n    def __init__(self, src_field: Union['SourceField', str],\n                 history_length: int):\n\"\"\"\n        See [historical_dependency][pybrook.models.historical_dependency].\n        \"\"\"\n        super().__init__(src_field)  # type: ignore\n        self.history_length = history_length\n        self.is_historical = True\n\n    @property\n    def value_type(self):\n        return List[Union[self.src_field.value_type, None]]\n\n    def validate_source_field(self, src: DependencySource):\n        if isinstance(src, str):\n            return src\n        return super().validate_source_field(src)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.HistoricalDependency.history_length","title":"<code>history_length = history_length</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.HistoricalDependency.is_historical","title":"<code>is_historical = True</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.HistoricalDependency.value_type","title":"<code>value_type</code>  <code>property</code>","text":""},{"location":"reference/models.html#pybrook.models.HistoricalDependency.__init__","title":"<code>__init__(src_field, history_length)</code>","text":"<p>See historical_dependency.</p> Source code in <code>pybrook/models.py</code> <pre><code>def __init__(self, src_field: Union['SourceField', str],\n             history_length: int):\n\"\"\"\n    See [historical_dependency][pybrook.models.historical_dependency].\n    \"\"\"\n    super().__init__(src_field)  # type: ignore\n    self.history_length = history_length\n    self.is_historical = True\n</code></pre>"},{"location":"reference/models.html#pybrook.models.HistoricalDependency.validate_source_field","title":"<code>validate_source_field(src)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def validate_source_field(self, src: DependencySource):\n    if isinstance(src, str):\n        return src\n    return super().validate_source_field(src)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.InReport","title":"<code>InReport</code>","text":"<p>         Bases: <code>ConsumerGenerator</code>, <code>RouteGenerator</code>, <code>pydantic.BaseModel</code></p> Source code in <code>pybrook/models.py</code> <pre><code>class InReport(ConsumerGenerator,\n               RouteGenerator,\n               pydantic.BaseModel,\n               metaclass=InReportMeta):\n    @classmethod\n    def gen_consumers(cls, model: 'PyBrook'):\n        splitter = Splitter(\n            redis_url=model.redis_url,\n            object_id_field=cls.pybrook_options.id_field,\n            consumer_group_name=f'{cls.pybrook_options.name}{SPECIAL_CHAR}sp',\n            namespace=cls.pybrook_options.name,\n            input_streams=[cls.pybrook_options.stream_name])\n        model.add_consumer(splitter)\n\n    @classmethod\n    def gen_routes(cls, api: 'PyBrookApi', redis_dep: aioredis.Redis):\n        @api.fastapi.post(f'/{cls.pybrook_options.name}',\n                          name=f'Add {cls.pybrook_options.name}')\n        async def add_report(\n                report: cls = fastapi.Body(...),  # type: ignore\n                redis_conn: aioredis.Redis = redis_dep):\n            await redis_conn.xadd(\n                cls.pybrook_options.stream_name,\n                encode_stream_message(\n                    report.dict(by_alias=False))  # type: ignore\n            )\n</code></pre>"},{"location":"reference/models.html#pybrook.models.InReport.gen_consumers","title":"<code>gen_consumers(model)</code>  <code>classmethod</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>@classmethod\ndef gen_consumers(cls, model: 'PyBrook'):\n    splitter = Splitter(\n        redis_url=model.redis_url,\n        object_id_field=cls.pybrook_options.id_field,\n        consumer_group_name=f'{cls.pybrook_options.name}{SPECIAL_CHAR}sp',\n        namespace=cls.pybrook_options.name,\n        input_streams=[cls.pybrook_options.stream_name])\n    model.add_consumer(splitter)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.InReport.gen_routes","title":"<code>gen_routes(api, redis_dep)</code>  <code>classmethod</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>@classmethod\ndef gen_routes(cls, api: 'PyBrookApi', redis_dep: aioredis.Redis):\n    @api.fastapi.post(f'/{cls.pybrook_options.name}',\n                      name=f'Add {cls.pybrook_options.name}')\n    async def add_report(\n            report: cls = fastapi.Body(...),  # type: ignore\n            redis_conn: aioredis.Redis = redis_dep):\n        await redis_conn.xadd(\n            cls.pybrook_options.stream_name,\n            encode_stream_message(\n                report.dict(by_alias=False))  # type: ignore\n        )\n</code></pre>"},{"location":"reference/models.html#pybrook.models.InReportMeta","title":"<code>InReportMeta</code>","text":"<p>         Bases: <code>OptionsMixin[InReportOptions]</code>, <code>pydantic.main.ModelMetaclass</code></p> Source code in <code>pybrook/models.py</code> <pre><code>class InReportMeta(OptionsMixin[InReportOptions],\n                   pydantic.main.ModelMetaclass):\n    pybrook_options: InReportOptions\n    _input_fields: Dict[str, 'InputField']\n\n    def __new__(mcs, name, bases, namespace):  # noqa: N804\n\"\"\"\n        Initialize an InReport subclass by generating a dictionary\n        of [InputFields][pybrook.models.InputField] from the Pydantic fields provided.\n        \"\"\"\n        cls = super().__new__(mcs, name, bases, namespace)  # noqa: WPS117\n        cls._input_fields = {}\n        for prop_name, field in cls.__fields__.items():\n            cls._input_fields[prop_name] = InputField(cls,\n                                                      field)  # type: ignore\n        return cls\n\n    def __getattr__(cls, item: str) -&gt; SourceField:  # noqa: N805\n\"\"\"This enables the `Model.field` syntax used for references in PyBrook models.\"\"\"\n        if not item.startswith('_') and item in cls._input_fields:\n            return cls._input_fields[item]\n        return super().__getattribute__(item)  # noqa: WPS613\n\n    def _validate_options(\n            cls, options: InReportOptions) -&gt; InReportOptions:  # noqa: N805\n\"\"\"Validate options set by [PyBrook.input()][pybrook.models.PyBrook.input]\"\"\"\n        try:\n            getattr(cls, options.id_field)\n        except AttributeError:\n            raise RuntimeError(\n                f'Invalid id_field! {cls.__name__} '\n                f'has no attribute \"{options.id_field}\".') from None\n        return options\n</code></pre>"},{"location":"reference/models.html#pybrook.models.InReportMeta._input_fields","title":"<code>_input_fields: Dict[str, InputField]</code>  <code>class-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.InReportMeta.pybrook_options","title":"<code>pybrook_options: InReportOptions</code>  <code>class-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.InReportMeta.__getattr__","title":"<code>__getattr__(item)</code>","text":"<p>This enables the <code>Model.field</code> syntax used for references in PyBrook models.</p> Source code in <code>pybrook/models.py</code> <pre><code>def __getattr__(cls, item: str) -&gt; SourceField:  # noqa: N805\n\"\"\"This enables the `Model.field` syntax used for references in PyBrook models.\"\"\"\n    if not item.startswith('_') and item in cls._input_fields:\n        return cls._input_fields[item]\n    return super().__getattribute__(item)  # noqa: WPS613\n</code></pre>"},{"location":"reference/models.html#pybrook.models.InReportMeta.__new__","title":"<code>__new__(mcs, name, bases, namespace)</code>","text":"<p>Initialize an InReport subclass by generating a dictionary of InputFields from the Pydantic fields provided.</p> Source code in <code>pybrook/models.py</code> <pre><code>def __new__(mcs, name, bases, namespace):  # noqa: N804\n\"\"\"\n    Initialize an InReport subclass by generating a dictionary\n    of [InputFields][pybrook.models.InputField] from the Pydantic fields provided.\n    \"\"\"\n    cls = super().__new__(mcs, name, bases, namespace)  # noqa: WPS117\n    cls._input_fields = {}\n    for prop_name, field in cls.__fields__.items():\n        cls._input_fields[prop_name] = InputField(cls,\n                                                  field)  # type: ignore\n    return cls\n</code></pre>"},{"location":"reference/models.html#pybrook.models.InReportMeta._validate_options","title":"<code>_validate_options(options)</code>","text":"<p>Validate options set by PyBrook.input()</p> Source code in <code>pybrook/models.py</code> <pre><code>def _validate_options(\n        cls, options: InReportOptions) -&gt; InReportOptions:  # noqa: N805\n\"\"\"Validate options set by [PyBrook.input()][pybrook.models.PyBrook.input]\"\"\"\n    try:\n        getattr(cls, options.id_field)\n    except AttributeError:\n        raise RuntimeError(\n            f'Invalid id_field! {cls.__name__} '\n            f'has no attribute \"{options.id_field}\".') from None\n    return options\n</code></pre>"},{"location":"reference/models.html#pybrook.models.InReportOptions","title":"<code>InReportOptions</code>  <code>dataclass</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>@dataclasses.dataclass\nclass InReportOptions:\n    id_field: str\n    name: str\n\n    @property\n    def stream_name(self):\n        return f'{SPECIAL_CHAR}{self.name}'\n</code></pre>"},{"location":"reference/models.html#pybrook.models.InReportOptions.id_field","title":"<code>id_field: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.InReportOptions.name","title":"<code>name: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.InReportOptions.stream_name","title":"<code>stream_name</code>  <code>property</code>","text":""},{"location":"reference/models.html#pybrook.models.InputField","title":"<code>InputField</code>","text":"<p>         Bases: <code>SourceField</code></p> Source code in <code>pybrook/models.py</code> <pre><code>class InputField(SourceField):\n    def __init__(self, report_class: Type[InReport],\n                 pydantic_field: pydantic.fields.ModelField):\n        super().__init__(pydantic_field.name,\n                         value_type=pydantic_field.type_,\n                         source_obj=report_class)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.InputField.__init__","title":"<code>__init__(report_class, pydantic_field)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __init__(self, report_class: Type[InReport],\n             pydantic_field: pydantic.fields.ModelField):\n    super().__init__(pydantic_field.name,\n                     value_type=pydantic_field.type_,\n                     source_obj=report_class)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.OptionsMixin","title":"<code>OptionsMixin</code>","text":"<p>         Bases: <code>Generic[TOPT]</code></p> <p>A mixin used by metaclasses InReportMeta and OutReportMeta.</p> <p>It's responsibility is to add a <code>pybrook_options</code> property, that allows setting &amp; validating passed options.</p> Source code in <code>pybrook/models.py</code> <pre><code>class OptionsMixin(Generic[TOPT]):\n\"\"\"\n    A mixin used by metaclasses [InReportMeta][pybrook.models.InReportMeta] and [OutReportMeta][pybrook.models.OutReportMeta].\n\n    It's responsibility is to add a `pybrook_options` property, that allows setting &amp; validating passed options.\n    \"\"\"\n    @property\n    def pybrook_options(self) -&gt; TOPT:\n\"\"\"A property containing report options, like `id_field` or `name`.\"\"\"\n        return self._options\n\n    @pybrook_options.setter\n    def pybrook_options(self, options: TOPT):\n        options = self._validate_options(options)\n        self._options = options  # noqa: WPS112\n\n    def _validate_options(self, options: TOPT) -&gt; TOPT:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/models.html#pybrook.models.OptionsMixin.pybrook_options","title":"<code>pybrook_options: TOPT</code>  <code>property</code> <code>writable</code>","text":"<p>A property containing report options, like <code>id_field</code> or <code>name</code>.</p>"},{"location":"reference/models.html#pybrook.models.OptionsMixin._validate_options","title":"<code>_validate_options(options)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def _validate_options(self, options: TOPT) -&gt; TOPT:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/models.html#pybrook.models.OutReport","title":"<code>OutReport</code>","text":"<p>         Bases: <code>ConsumerGenerator</code>, <code>RouteGenerator</code></p> Source code in <code>pybrook/models.py</code> <pre><code>class OutReport(ConsumerGenerator, RouteGenerator, metaclass=OutReportMeta):\n    @classmethod\n    def gen_routes(  # noqa: WPS217, WPS231\n            cls, api: 'PyBrookApi', redis_dep: aioredis.Redis):\n        model_cls = cls.pydantic_model\n\n        @api.fastapi.get(\n            f'/{cls.pybrook_options.name}',\n            response_model=model_cls,  # type: ignore\n            name=f'Retrieve {cls.pybrook_options.name}')\n        async def get_report(redis_conn: aioredis.Redis = redis_dep):\n            messages = await redis_conn.xrevrange(\n                cls.pybrook_options.stream_name, count=1)\n            for _msg_id, msg_body in messages:  # noqa: WPS328\n                return model_cls(**decode_stream_message(msg_body))\n            return {}\n\n        @api.fastapi.websocket(f'/{cls.pybrook_options.name}')\n        async def read_reports(  # noqa: WPS231\n                websocket: fastapi.WebSocket,\n                redis_conn: aioredis.Redis = redis_dep):\n            await websocket.accept()\n            last_msg = '$'\n            stream_name = cls.pybrook_options.stream_name\n            active = True\n            last_ping = time()\n            while active and api.fastapi.state.socket_active:\n                if time() - last_ping &gt; WEBSOCKET_PING_INTERVAL:\n                    try:\n                        # Check if connection is active\n                        await asyncio.wait_for(websocket.receive_bytes(),\n                                               timeout=WEBSOCKET_WAIT_TIME)\n                    except asyncio.TimeoutError:\n                        ...  # Everything is OK\n                    except (fastapi.WebSocketDisconnect, AssertionError):\n                        active = False\n                    else:\n                        last_ping = time()\n                messages = await redis_conn.xread({stream_name: last_msg},\n                                                  count=WEBSOCKET_XREAD_COUNT,\n                                                  block=WEBSOCKET_XREAD_BLOCK)\n                if messages:\n                    # Wiadomo\u015bci w strumieniach s\u0105 mapami\n                    for m_data in dict(messages)[stream_name]:\n                        last_msg, payload = m_data\n                        try:\n                            await websocket.send_text(\n                                model_cls(\n                                    **decode_stream_message(payload)).json())\n                        except ConnectionClosedOK:\n                            active = False\n                        except RuntimeError:\n                            active = False\n            try:\n                await websocket.close()\n            except RuntimeError:\n                logger.info('WebSocket connection closed by client')\n            else:\n                logger.info('WebSocket connection closed by server')\n\n        api.schema.streams.append(\n            StreamInfo(stream_name=cls.pybrook_options.stream_name,\n                       websocket_path=f'/{cls.pybrook_options.name}',\n                       report_schema=cls.pydantic_model.schema()))\n\n    @classmethod\n    def gen_consumers(cls, model: 'PyBrook'):\n        dependency_resolver = DependencyResolver(\n            redis_url=model.redis_url,\n            output_stream_name=cls.pybrook_options.stream_name,\n            dependencies=[\n                DependencyResolver.Dep(\n                    src_stream=field.source_field.stream_name,\n                    src_key=field.source_field.field_name,\n                    dst_key=field.destination_field_name)\n                for field in cls._report_fields.values()\n            ],\n            resolver_name=cls.pybrook_options.name)\n        model.add_consumer(dependency_resolver)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.OutReport.gen_consumers","title":"<code>gen_consumers(model)</code>  <code>classmethod</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>@classmethod\ndef gen_consumers(cls, model: 'PyBrook'):\n    dependency_resolver = DependencyResolver(\n        redis_url=model.redis_url,\n        output_stream_name=cls.pybrook_options.stream_name,\n        dependencies=[\n            DependencyResolver.Dep(\n                src_stream=field.source_field.stream_name,\n                src_key=field.source_field.field_name,\n                dst_key=field.destination_field_name)\n            for field in cls._report_fields.values()\n        ],\n        resolver_name=cls.pybrook_options.name)\n    model.add_consumer(dependency_resolver)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.OutReport.gen_routes","title":"<code>gen_routes(api, redis_dep)</code>  <code>classmethod</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>@classmethod\ndef gen_routes(  # noqa: WPS217, WPS231\n        cls, api: 'PyBrookApi', redis_dep: aioredis.Redis):\n    model_cls = cls.pydantic_model\n\n    @api.fastapi.get(\n        f'/{cls.pybrook_options.name}',\n        response_model=model_cls,  # type: ignore\n        name=f'Retrieve {cls.pybrook_options.name}')\n    async def get_report(redis_conn: aioredis.Redis = redis_dep):\n        messages = await redis_conn.xrevrange(\n            cls.pybrook_options.stream_name, count=1)\n        for _msg_id, msg_body in messages:  # noqa: WPS328\n            return model_cls(**decode_stream_message(msg_body))\n        return {}\n\n    @api.fastapi.websocket(f'/{cls.pybrook_options.name}')\n    async def read_reports(  # noqa: WPS231\n            websocket: fastapi.WebSocket,\n            redis_conn: aioredis.Redis = redis_dep):\n        await websocket.accept()\n        last_msg = '$'\n        stream_name = cls.pybrook_options.stream_name\n        active = True\n        last_ping = time()\n        while active and api.fastapi.state.socket_active:\n            if time() - last_ping &gt; WEBSOCKET_PING_INTERVAL:\n                try:\n                    # Check if connection is active\n                    await asyncio.wait_for(websocket.receive_bytes(),\n                                           timeout=WEBSOCKET_WAIT_TIME)\n                except asyncio.TimeoutError:\n                    ...  # Everything is OK\n                except (fastapi.WebSocketDisconnect, AssertionError):\n                    active = False\n                else:\n                    last_ping = time()\n            messages = await redis_conn.xread({stream_name: last_msg},\n                                              count=WEBSOCKET_XREAD_COUNT,\n                                              block=WEBSOCKET_XREAD_BLOCK)\n            if messages:\n                # Wiadomo\u015bci w strumieniach s\u0105 mapami\n                for m_data in dict(messages)[stream_name]:\n                    last_msg, payload = m_data\n                    try:\n                        await websocket.send_text(\n                            model_cls(\n                                **decode_stream_message(payload)).json())\n                    except ConnectionClosedOK:\n                        active = False\n                    except RuntimeError:\n                        active = False\n        try:\n            await websocket.close()\n        except RuntimeError:\n            logger.info('WebSocket connection closed by client')\n        else:\n            logger.info('WebSocket connection closed by server')\n\n    api.schema.streams.append(\n        StreamInfo(stream_name=cls.pybrook_options.stream_name,\n                   websocket_path=f'/{cls.pybrook_options.name}',\n                   report_schema=cls.pydantic_model.schema()))\n</code></pre>"},{"location":"reference/models.html#pybrook.models.OutReportMeta","title":"<code>OutReportMeta</code>","text":"<p>         Bases: <code>OptionsMixin[OutReportOptions]</code>, <code>type</code></p> Source code in <code>pybrook/models.py</code> <pre><code>class OutReportMeta(OptionsMixin[OutReportOptions], type):\n    _report_fields: Mapping[str, 'ReportField']\n    _model: Type[pydantic.BaseModel]\n    pybrook_options: OutReportOptions\n\n    def __new__(mcs, name, bases, namespace):  # noqa: N804\n\"\"\"\n        Initialize an [OutReport][pybrook.models.OutReport] subclass by processing all of its ReportFields,\n        and initializing the [pydantic_model][pybrook.models.OutReportMeta.pydantic_model] property.\n        \"\"\"\n        cls = super().__new__(mcs, name, bases, namespace)  # noqa: WPS117\n        cls._report_fields = {}\n        for prop_name, report_field in inspect.getmembers(cls):\n            if isinstance(report_field, ReportField):\n                report_field.set_context(cls, prop_name)\n                cls._report_fields[prop_name] = report_field\n        pydantic_fields = {\n            rep_field.destination_field_name:\n            (rep_field.source_field.value_type, pydantic.Field())\n            for rep_field in cls._report_fields.values()  # type: ignore\n        }\n        pydantic_fields[MSG_ID_FIELD] = (\n            str,\n            pydantic.Field(\n                title='Message ID',\n                description=(f'Message id - {{object ID}}'\n                             f'{SPECIAL_CHAR}{{msg index for object}}')))\n        cls._model = pydantic.create_model(\n            cls.__name__ + 'Model',\n            **pydantic_fields  # type: ignore\n        )\n        return cls\n\n    @property\n    def stream_name(cls):\n        return cls.pybrook_options.stream_name\n\n    @property  # type: ignore\n    def pydantic_model(cls) -&gt; Type[pydantic.BaseModel]:\n\"\"\"\n        A Pydantic model describing the output report.\n        \"\"\"\n        pydantic_fields = {\n            report_field.destination_field_name:\n            (report_field.source_field.value_type, pydantic.Field())\n            for report_field in cls._report_fields.values()  # type: ignore\n        }\n        pydantic_fields[MSG_ID_FIELD] = (\n            str,\n            pydantic.Field(\n                title='Message ID',\n                description=(f'Message id - {{object ID}}'\n                             f'{SPECIAL_CHAR}{{msg index for object}}')))\n        if not hasattr(cls, '_model'):\n            cls._model: Type[pydantic.BaseModel] = pydantic.create_model(\n                cls.__name__ + 'Model',\n                **pydantic_fields  # type: ignore\n            )\n        return cls._model\n\n    def _validate_options(cls, options: OutReportOptions) -&gt; OutReportOptions:\n        return options\n</code></pre>"},{"location":"reference/models.html#pybrook.models.OutReportMeta._model","title":"<code>_model: Type[pydantic.BaseModel]</code>  <code>class-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.OutReportMeta._report_fields","title":"<code>_report_fields: Mapping[str, ReportField]</code>  <code>class-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.OutReportMeta.pybrook_options","title":"<code>pybrook_options: OutReportOptions</code>  <code>class-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.OutReportMeta.pydantic_model","title":"<code>pydantic_model: Type[pydantic.BaseModel]</code>  <code>property</code>","text":"<p>A Pydantic model describing the output report.</p>"},{"location":"reference/models.html#pybrook.models.OutReportMeta.stream_name","title":"<code>stream_name</code>  <code>property</code>","text":""},{"location":"reference/models.html#pybrook.models.OutReportMeta.__new__","title":"<code>__new__(mcs, name, bases, namespace)</code>","text":"<p>Initialize an OutReport subclass by processing all of its ReportFields, and initializing the pydantic_model property.</p> Source code in <code>pybrook/models.py</code> <pre><code>def __new__(mcs, name, bases, namespace):  # noqa: N804\n\"\"\"\n    Initialize an [OutReport][pybrook.models.OutReport] subclass by processing all of its ReportFields,\n    and initializing the [pydantic_model][pybrook.models.OutReportMeta.pydantic_model] property.\n    \"\"\"\n    cls = super().__new__(mcs, name, bases, namespace)  # noqa: WPS117\n    cls._report_fields = {}\n    for prop_name, report_field in inspect.getmembers(cls):\n        if isinstance(report_field, ReportField):\n            report_field.set_context(cls, prop_name)\n            cls._report_fields[prop_name] = report_field\n    pydantic_fields = {\n        rep_field.destination_field_name:\n        (rep_field.source_field.value_type, pydantic.Field())\n        for rep_field in cls._report_fields.values()  # type: ignore\n    }\n    pydantic_fields[MSG_ID_FIELD] = (\n        str,\n        pydantic.Field(\n            title='Message ID',\n            description=(f'Message id - {{object ID}}'\n                         f'{SPECIAL_CHAR}{{msg index for object}}')))\n    cls._model = pydantic.create_model(\n        cls.__name__ + 'Model',\n        **pydantic_fields  # type: ignore\n    )\n    return cls\n</code></pre>"},{"location":"reference/models.html#pybrook.models.OutReportMeta._validate_options","title":"<code>_validate_options(options)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def _validate_options(cls, options: OutReportOptions) -&gt; OutReportOptions:\n    return options\n</code></pre>"},{"location":"reference/models.html#pybrook.models.OutReportOptions","title":"<code>OutReportOptions</code>  <code>dataclass</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>@dataclasses.dataclass\nclass OutReportOptions:\n    name: str\n\n    @property\n    def stream_name(self):\n        return f'{SPECIAL_CHAR}{self.name}'\n</code></pre>"},{"location":"reference/models.html#pybrook.models.OutReportOptions.name","title":"<code>name: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.OutReportOptions.stream_name","title":"<code>stream_name</code>  <code>property</code>","text":""},{"location":"reference/models.html#pybrook.models.PyBrook","title":"<code>PyBrook</code>","text":"<p>This class represents a PyBrook model.</p> Source code in <code>pybrook/models.py</code> <pre><code>class PyBrook:\n\"\"\"This class represents a PyBrook model.\"\"\"\n    def __init__(self,\n                 redis_url: str,\n                 api_class: Type[PyBrookApi] = PyBrookApi):\n\"\"\"\n        Args:\n            redis_url: Url of the Redis Gears server.\n            api_class: API class - you can pass your own implementation of\n            [PyBrookApi][pybrook.models.PyBrookApi] to modify the generated FastAPI app.\n        \"\"\"\n        self.inputs: Dict[str, Type[InReport]] = {}\n        self.outputs: Dict[str, Type[OutReport]] = {}\n        self.artificial_fields: Dict[str, ArtificialField] = {}\n        self.consumers: List[BaseStreamConsumer] = []\n        self.redis_url: str = redis_url\n        self.api: PyBrookApi = api_class(self)\n        self.manager: Optional[WorkerManager] = None\n\n    def process_model(self):\n        if not self.consumers:\n            report_classes = chain(self.inputs.values(), self.outputs.values())\n            for report_class in report_classes:\n                self.visit(report_class)\n            for field in self.artificial_fields.values():\n                self.visit(field)\n\n    @property\n    def app(self) -&gt; fastapi.FastAPI:\n        self.process_model()\n        return self.api.fastapi\n\n    def run(self, config: Dict[str, ConsumerConfig] = None):\n\"\"\"\n        Runs the workers.\n\n        Args:\n            config: Consumer config, can be skipped - defaults will be used. See [pybrook.__main__][pybrook.__main__] for details.\n        \"\"\"\n\n        config = config or {}\n        self.process_model()\n        self.manager = WorkerManager(self.consumers, config=config)\n        self.manager.run()\n\n    def terminate(self):\n\"\"\"Terminates all worker processes gracefully.\"\"\"\n        if not self.manager:\n            raise RuntimeError('PyBrook is not running!')\n        self.manager.terminate()\n\n    def set_meta(self,\n                 *,\n                 latitude_field: ReportField,\n                 longitude_field: ReportField,\n                 group_field: ReportField,\n                 time_field: ReportField,\n                 direction_field: ReportField = None):\n\"\"\"Use this method to set metadata used by frontend.\"\"\"\n        self.api.schema.latitude_field = self._gen_field_info(latitude_field)\n        self.api.schema.longitude_field = self._gen_field_info(longitude_field)\n        self.api.schema.group_field = self._gen_field_info(group_field)\n        self.api.schema.time_field = self._gen_field_info(time_field)\n        if direction_field:\n            self.api.schema.direction_field = self._gen_field_info(\n                direction_field)\n\n    def input(  # noqa: A003\n            self, name: str = None, *, id_field: str) -&gt; Callable[[TI], TI]:\n\"\"\"\n        Register an input report.\n\n        Returns:\n            A decorator, which accepts an InReport as an argument.\n        \"\"\"\n        def wrapper(cls) -&gt; TI:\n            name_safe = name or cls.__name__\n            self.inputs[name_safe] = cls\n            cls.pybrook_options = InReportOptions(id_field=id_field,\n                                                  name=name_safe)\n            self.api.visit(cls)\n            return cls\n\n        return wrapper\n\n    def output(self, name: str = None) -&gt; Callable[[TO], TO]:\n\"\"\"\n        Register an output report.\n\n        Returns:\n            A decorator, which accepts an OutReport as an argument.\n        \"\"\"\n        def wrapper(cls) -&gt; TO:\n            name_safe = name or cls.__name__\n            self.outputs[name_safe] = cls\n            cls.pybrook_options = OutReportOptions(name=name_safe)\n            self.api.visit(cls)\n            return cls\n\n        return wrapper\n\n    def artificial_field(self, name: str = None) -&gt; Callable[[Callable], Any]:\n\"\"\"\n        Register an artificial field.\n\n        Returns:\n            A decorator, which accepts a callable as an argument.\n            The callable provided is used to calculate the value of the artificial field.\n        \"\"\"\n        def wrapper(fun: Callable) -&gt; Any:\n            field = ArtificialField(fun, name=name)\n            self.artificial_fields[name or fun.__name__] = field\n            field.on_registered(self)\n            return field\n\n        return wrapper\n\n    def visit(self, generator: ConsumerGenerator):\n\"\"\"Visit a consumer generator and let it generate consumers.\"\"\"\n        generator.gen_consumers(self)\n\n    def add_consumer(self, consumer: BaseStreamConsumer):\n\"\"\"\n        This is used by consumer generators.\n\n        For now it just adds a new consumer to the consumer list.\n        \"\"\"\n\n        self.consumers.append(consumer)\n\n    def _gen_field_info(self, field: ReportField) -&gt; FieldInfo:\n        return FieldInfo(stream_name=field.destination_stream_name,\n                         field_name=field.destination_field_name)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.PyBrook.api","title":"<code>api: PyBrookApi = api_class(self)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.PyBrook.app","title":"<code>app: fastapi.FastAPI</code>  <code>property</code>","text":""},{"location":"reference/models.html#pybrook.models.PyBrook.artificial_fields","title":"<code>artificial_fields: Dict[str, ArtificialField] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.PyBrook.consumers","title":"<code>consumers: List[BaseStreamConsumer] = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.PyBrook.inputs","title":"<code>inputs: Dict[str, Type[InReport]] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.PyBrook.manager","title":"<code>manager: Optional[WorkerManager] = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.PyBrook.outputs","title":"<code>outputs: Dict[str, Type[OutReport]] = {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.PyBrook.redis_url","title":"<code>redis_url: str = redis_url</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.PyBrook.__init__","title":"<code>__init__(redis_url, api_class=PyBrookApi)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>redis_url</code> <code>str</code> <p>Url of the Redis Gears server.</p> required <code>api_class</code> <code>Type[PyBrookApi]</code> <p>API class - you can pass your own implementation of</p> <code>PyBrookApi</code> Source code in <code>pybrook/models.py</code> <pre><code>def __init__(self,\n             redis_url: str,\n             api_class: Type[PyBrookApi] = PyBrookApi):\n\"\"\"\n    Args:\n        redis_url: Url of the Redis Gears server.\n        api_class: API class - you can pass your own implementation of\n        [PyBrookApi][pybrook.models.PyBrookApi] to modify the generated FastAPI app.\n    \"\"\"\n    self.inputs: Dict[str, Type[InReport]] = {}\n    self.outputs: Dict[str, Type[OutReport]] = {}\n    self.artificial_fields: Dict[str, ArtificialField] = {}\n    self.consumers: List[BaseStreamConsumer] = []\n    self.redis_url: str = redis_url\n    self.api: PyBrookApi = api_class(self)\n    self.manager: Optional[WorkerManager] = None\n</code></pre>"},{"location":"reference/models.html#pybrook.models.PyBrook._gen_field_info","title":"<code>_gen_field_info(field)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def _gen_field_info(self, field: ReportField) -&gt; FieldInfo:\n    return FieldInfo(stream_name=field.destination_stream_name,\n                     field_name=field.destination_field_name)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.PyBrook.add_consumer","title":"<code>add_consumer(consumer)</code>","text":"<p>This is used by consumer generators.</p> <p>For now it just adds a new consumer to the consumer list.</p> Source code in <code>pybrook/models.py</code> <pre><code>def add_consumer(self, consumer: BaseStreamConsumer):\n\"\"\"\n    This is used by consumer generators.\n\n    For now it just adds a new consumer to the consumer list.\n    \"\"\"\n\n    self.consumers.append(consumer)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.PyBrook.artificial_field","title":"<code>artificial_field(name=None)</code>","text":"<p>Register an artificial field.</p> <p>Returns:</p> Type Description <code>Callable[[Callable], Any]</code> <p>A decorator, which accepts a callable as an argument.</p> <code>Callable[[Callable], Any]</code> <p>The callable provided is used to calculate the value of the artificial field.</p> Source code in <code>pybrook/models.py</code> <pre><code>def artificial_field(self, name: str = None) -&gt; Callable[[Callable], Any]:\n\"\"\"\n    Register an artificial field.\n\n    Returns:\n        A decorator, which accepts a callable as an argument.\n        The callable provided is used to calculate the value of the artificial field.\n    \"\"\"\n    def wrapper(fun: Callable) -&gt; Any:\n        field = ArtificialField(fun, name=name)\n        self.artificial_fields[name or fun.__name__] = field\n        field.on_registered(self)\n        return field\n\n    return wrapper\n</code></pre>"},{"location":"reference/models.html#pybrook.models.PyBrook.input","title":"<code>input(name=None, *, id_field)</code>","text":"<p>Register an input report.</p> <p>Returns:</p> Type Description <code>Callable[[TI], TI]</code> <p>A decorator, which accepts an InReport as an argument.</p> Source code in <code>pybrook/models.py</code> <pre><code>def input(  # noqa: A003\n        self, name: str = None, *, id_field: str) -&gt; Callable[[TI], TI]:\n\"\"\"\n    Register an input report.\n\n    Returns:\n        A decorator, which accepts an InReport as an argument.\n    \"\"\"\n    def wrapper(cls) -&gt; TI:\n        name_safe = name or cls.__name__\n        self.inputs[name_safe] = cls\n        cls.pybrook_options = InReportOptions(id_field=id_field,\n                                              name=name_safe)\n        self.api.visit(cls)\n        return cls\n\n    return wrapper\n</code></pre>"},{"location":"reference/models.html#pybrook.models.PyBrook.output","title":"<code>output(name=None)</code>","text":"<p>Register an output report.</p> <p>Returns:</p> Type Description <code>Callable[[TO], TO]</code> <p>A decorator, which accepts an OutReport as an argument.</p> Source code in <code>pybrook/models.py</code> <pre><code>def output(self, name: str = None) -&gt; Callable[[TO], TO]:\n\"\"\"\n    Register an output report.\n\n    Returns:\n        A decorator, which accepts an OutReport as an argument.\n    \"\"\"\n    def wrapper(cls) -&gt; TO:\n        name_safe = name or cls.__name__\n        self.outputs[name_safe] = cls\n        cls.pybrook_options = OutReportOptions(name=name_safe)\n        self.api.visit(cls)\n        return cls\n\n    return wrapper\n</code></pre>"},{"location":"reference/models.html#pybrook.models.PyBrook.process_model","title":"<code>process_model()</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def process_model(self):\n    if not self.consumers:\n        report_classes = chain(self.inputs.values(), self.outputs.values())\n        for report_class in report_classes:\n            self.visit(report_class)\n        for field in self.artificial_fields.values():\n            self.visit(field)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.PyBrook.run","title":"<code>run(config=None)</code>","text":"<p>Runs the workers.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict[str, ConsumerConfig]</code> <p>Consumer config, can be skipped - defaults will be used. See pybrook.main for details.</p> <code>None</code> Source code in <code>pybrook/models.py</code> <pre><code>def run(self, config: Dict[str, ConsumerConfig] = None):\n\"\"\"\n    Runs the workers.\n\n    Args:\n        config: Consumer config, can be skipped - defaults will be used. See [pybrook.__main__][pybrook.__main__] for details.\n    \"\"\"\n\n    config = config or {}\n    self.process_model()\n    self.manager = WorkerManager(self.consumers, config=config)\n    self.manager.run()\n</code></pre>"},{"location":"reference/models.html#pybrook.models.PyBrook.set_meta","title":"<code>set_meta(*, latitude_field, longitude_field, group_field, time_field, direction_field=None)</code>","text":"<p>Use this method to set metadata used by frontend.</p> Source code in <code>pybrook/models.py</code> <pre><code>def set_meta(self,\n             *,\n             latitude_field: ReportField,\n             longitude_field: ReportField,\n             group_field: ReportField,\n             time_field: ReportField,\n             direction_field: ReportField = None):\n\"\"\"Use this method to set metadata used by frontend.\"\"\"\n    self.api.schema.latitude_field = self._gen_field_info(latitude_field)\n    self.api.schema.longitude_field = self._gen_field_info(longitude_field)\n    self.api.schema.group_field = self._gen_field_info(group_field)\n    self.api.schema.time_field = self._gen_field_info(time_field)\n    if direction_field:\n        self.api.schema.direction_field = self._gen_field_info(\n            direction_field)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.PyBrook.terminate","title":"<code>terminate()</code>","text":"<p>Terminates all worker processes gracefully.</p> Source code in <code>pybrook/models.py</code> <pre><code>def terminate(self):\n\"\"\"Terminates all worker processes gracefully.\"\"\"\n    if not self.manager:\n        raise RuntimeError('PyBrook is not running!')\n    self.manager.terminate()\n</code></pre>"},{"location":"reference/models.html#pybrook.models.PyBrook.visit","title":"<code>visit(generator)</code>","text":"<p>Visit a consumer generator and let it generate consumers.</p> Source code in <code>pybrook/models.py</code> <pre><code>def visit(self, generator: ConsumerGenerator):\n\"\"\"Visit a consumer generator and let it generate consumers.\"\"\"\n    generator.gen_consumers(self)\n</code></pre>"},{"location":"reference/models.html#pybrook.models.PyBrookApi","title":"<code>PyBrookApi</code>","text":"<p>Represents the HTTP API.</p> <p>The default implementation is based on FastAPI.</p> Source code in <code>pybrook/models.py</code> <pre><code>class PyBrookApi:\n\"\"\"\n    Represents the HTTP API.\n\n    The default implementation is based on FastAPI.\n    \"\"\"\n    def __init__(self, brook: 'PyBrook'):\n        self.fastapi = fastapi.FastAPI()\n        self.brook = brook\n        self.schema = PyBrookSchema()\n        self.fastapi.add_middleware(CORSMiddleware,\n                                    allow_credentials=True,\n                                    allow_origins=['*'],\n                                    allow_methods=[\"*\"],\n                                    allow_headers=[\"*\"])\n\n        @self.fastapi.get('/pybrook-schema.json', response_model=PyBrookSchema)\n        def get_schema():\n            return self.schema\n\n        @self.fastapi.on_event('startup')\n        async def startup():\n            frontend_dir = str(Path(__file__).parent / 'frontend')\n            self.fastapi.mount('/panel/',\n                               StaticFiles(directory=frontend_dir, html=True),\n                               name='static')\n            self.fastapi.state.redis = await aioredis.from_url(\n                self.brook.redis_url, encoding='utf-8', decode_responses=True)\n            self.fastapi.state.socket_active = True\n            signal.signal(signal.SIGINT, shutdown)\n            signal.signal(signal.SIGTERM, shutdown)\n\n        @self.fastapi.on_event('shutdown')\n        def shutdown(*args):\n            logger.info('set socket active to false')\n            self.fastapi.state.socket_active = False\n            asyncio.create_task(self.fastapi.state.redis.close())  # noqa: WPS219\n            asyncio.create_task(self.fastapi.state.redis.connection_pool.  # noqa: WPS219\n                                disconnect())\n\n    async def redis_dependency(self) -&gt; AsyncIterator[aioredis.Redis]:\n\"\"\"\n        Redis FastAPI Dependency\n\n        Yields:\n            A Redis connection\n        \"\"\"\n        yield self.fastapi.state.redis\n\n    def visit(self, generator: RouteGenerator):\n\"\"\"Visits a route generator to add new endpoints.\"\"\"\n        generator.gen_routes(self,\n                             redis_dep=fastapi.Depends(self.redis_dependency))\n</code></pre>"},{"location":"reference/models.html#pybrook.models.PyBrookApi.brook","title":"<code>brook = brook</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.PyBrookApi.fastapi","title":"<code>fastapi = fastapi.FastAPI()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.PyBrookApi.schema","title":"<code>schema = PyBrookSchema()</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.PyBrookApi.__init__","title":"<code>__init__(brook)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __init__(self, brook: 'PyBrook'):\n    self.fastapi = fastapi.FastAPI()\n    self.brook = brook\n    self.schema = PyBrookSchema()\n    self.fastapi.add_middleware(CORSMiddleware,\n                                allow_credentials=True,\n                                allow_origins=['*'],\n                                allow_methods=[\"*\"],\n                                allow_headers=[\"*\"])\n\n    @self.fastapi.get('/pybrook-schema.json', response_model=PyBrookSchema)\n    def get_schema():\n        return self.schema\n\n    @self.fastapi.on_event('startup')\n    async def startup():\n        frontend_dir = str(Path(__file__).parent / 'frontend')\n        self.fastapi.mount('/panel/',\n                           StaticFiles(directory=frontend_dir, html=True),\n                           name='static')\n        self.fastapi.state.redis = await aioredis.from_url(\n            self.brook.redis_url, encoding='utf-8', decode_responses=True)\n        self.fastapi.state.socket_active = True\n        signal.signal(signal.SIGINT, shutdown)\n        signal.signal(signal.SIGTERM, shutdown)\n\n    @self.fastapi.on_event('shutdown')\n    def shutdown(*args):\n        logger.info('set socket active to false')\n        self.fastapi.state.socket_active = False\n        asyncio.create_task(self.fastapi.state.redis.close())  # noqa: WPS219\n        asyncio.create_task(self.fastapi.state.redis.connection_pool.  # noqa: WPS219\n                            disconnect())\n</code></pre>"},{"location":"reference/models.html#pybrook.models.PyBrookApi.redis_dependency","title":"<code>redis_dependency()</code>  <code>async</code>","text":"<p>Redis FastAPI Dependency</p> <p>Yields:</p> Type Description <code>AsyncIterator[aioredis.Redis]</code> <p>A Redis connection</p> Source code in <code>pybrook/models.py</code> <pre><code>async def redis_dependency(self) -&gt; AsyncIterator[aioredis.Redis]:\n\"\"\"\n    Redis FastAPI Dependency\n\n    Yields:\n        A Redis connection\n    \"\"\"\n    yield self.fastapi.state.redis\n</code></pre>"},{"location":"reference/models.html#pybrook.models.PyBrookApi.visit","title":"<code>visit(generator)</code>","text":"<p>Visits a route generator to add new endpoints.</p> Source code in <code>pybrook/models.py</code> <pre><code>def visit(self, generator: RouteGenerator):\n\"\"\"Visits a route generator to add new endpoints.\"\"\"\n    generator.gen_routes(self,\n                         redis_dep=fastapi.Depends(self.redis_dependency))\n</code></pre>"},{"location":"reference/models.html#pybrook.models.Registrable","title":"<code>Registrable</code>","text":"<p>An interface describing objects that need to perform some tasks, after the initial processing stage is completed.</p> <p>This is used to solve issues like circular (recursive) references.</p> Source code in <code>pybrook/models.py</code> <pre><code>class Registrable:\n\"\"\"\n    An interface describing objects that need to perform some tasks, after the initial processing stage is completed.\n\n    This is used to solve issues like circular (recursive) references.\n    \"\"\"\n    def on_registered(self, model: 'PyBrook'):\n\"\"\"\n        Used mostly to evaluate lazy stuff.\n\n        Args:\n            model: The model to register at.\n\n        Raises:\n            NotImplementedError: When used directly.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/models.html#pybrook.models.Registrable.on_registered","title":"<code>on_registered(model)</code>","text":"<p>Used mostly to evaluate lazy stuff.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>PyBrook</code> <p>The model to register at.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>When used directly.</p> Source code in <code>pybrook/models.py</code> <pre><code>def on_registered(self, model: 'PyBrook'):\n\"\"\"\n    Used mostly to evaluate lazy stuff.\n\n    Args:\n        model: The model to register at.\n\n    Raises:\n        NotImplementedError: When used directly.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/models.html#pybrook.models.ReportField","title":"<code>ReportField</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>class ReportField:\n    def __init__(self, source_field: Union[SourceField, Any]):\n        if not isinstance(source_field, SourceField):\n            raise RuntimeError(f'{source_field} is not a SourceField')\n        self.destination_field_name: str\n        self.source_field = source_field\n        self.owner: Type[OutReport]\n\n    def __repr__(self):\n        return f'&lt;{self.__class__.__name__} ' \\\n               f'destination_field_name=\\'{self.destination_field_name}\\' ' \\\n               f'source_field={self.source_field} ' \\\n               f'owner={self.owner}&gt;'\n\n    @property\n    def destination_stream_name(self):\n        return self.owner.stream_name\n\n    def set_context(self, owner: Type['OutReport'], name: str):\n        self.owner = owner\n        self.destination_field_name = name\n</code></pre>"},{"location":"reference/models.html#pybrook.models.ReportField.destination_field_name","title":"<code>destination_field_name: str</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.ReportField.destination_stream_name","title":"<code>destination_stream_name</code>  <code>property</code>","text":""},{"location":"reference/models.html#pybrook.models.ReportField.owner","title":"<code>owner: Type[OutReport]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.ReportField.source_field","title":"<code>source_field = source_field</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.ReportField.__init__","title":"<code>__init__(source_field)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __init__(self, source_field: Union[SourceField, Any]):\n    if not isinstance(source_field, SourceField):\n        raise RuntimeError(f'{source_field} is not a SourceField')\n    self.destination_field_name: str\n    self.source_field = source_field\n    self.owner: Type[OutReport]\n</code></pre>"},{"location":"reference/models.html#pybrook.models.ReportField.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __repr__(self):\n    return f'&lt;{self.__class__.__name__} ' \\\n           f'destination_field_name=\\'{self.destination_field_name}\\' ' \\\n           f'source_field={self.source_field} ' \\\n           f'owner={self.owner}&gt;'\n</code></pre>"},{"location":"reference/models.html#pybrook.models.ReportField.set_context","title":"<code>set_context(owner, name)</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def set_context(self, owner: Type['OutReport'], name: str):\n    self.owner = owner\n    self.destination_field_name = name\n</code></pre>"},{"location":"reference/models.html#pybrook.models.RouteGenerator","title":"<code>RouteGenerator</code>","text":"<p>An interface describing objects that can generate API endpoints.</p> Source code in <code>pybrook/models.py</code> <pre><code>class RouteGenerator:\n\"\"\"\n    An interface describing objects that can generate API endpoints.\n    \"\"\"\n    @classmethod\n    def gen_routes(cls, api: 'PyBrookApi', redis_dep: aioredis.Redis):\n\"\"\"\n        Implementations of this method should add API endpoints\n        to the [PyBrookApi][pybrook.models.PyBrookApi] instance passed as `api`.\n\n        Args:\n            api: The PyBrookApi instance processed.\n            redis_dep: FastAPI redis dependency.\n\n        Raises:\n            NotImplementedError: When used directly.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/models.html#pybrook.models.RouteGenerator.gen_routes","title":"<code>gen_routes(api, redis_dep)</code>  <code>classmethod</code>","text":"<p>Implementations of this method should add API endpoints to the PyBrookApi instance passed as <code>api</code>.</p> <p>Parameters:</p> Name Type Description Default <code>api</code> <code>PyBrookApi</code> <p>The PyBrookApi instance processed.</p> required <code>redis_dep</code> <code>aioredis.Redis</code> <p>FastAPI redis dependency.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>When used directly.</p> Source code in <code>pybrook/models.py</code> <pre><code>@classmethod\ndef gen_routes(cls, api: 'PyBrookApi', redis_dep: aioredis.Redis):\n\"\"\"\n    Implementations of this method should add API endpoints\n    to the [PyBrookApi][pybrook.models.PyBrookApi] instance passed as `api`.\n\n    Args:\n        api: The PyBrookApi instance processed.\n        redis_dep: FastAPI redis dependency.\n\n    Raises:\n        NotImplementedError: When used directly.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/models.html#pybrook.models.SourceField","title":"<code>SourceField</code>","text":"<p>A base class for fields (InputField, ArtificialField)</p> <p>Provides metadata used to generate producers &amp; consumers.</p> Source code in <code>pybrook/models.py</code> <pre><code>class SourceField:\n\"\"\"\n    A base class for fields ([InputField][pybrook.models.InputField], [ArtificialField][pybrook.models.ArtificialField])\n\n    Provides metadata used to generate producers &amp; consumers.\n    \"\"\"\n    def __init__(self,\n                 field_name: str,\n                 *,\n                 value_type: Type,\n                 source_obj: Type['InReport'] = None):\n\"\"\"\n        Args:\n            value_type: Field value type.\n            field_name: Source field.\n            source_obj: InReport that the field belongs to.\n        \"\"\"\n        self.field_name: str = field_name\n        self.source_obj: Optional[Type[InReport]] = source_obj\n        self._value_type: Type = value_type\n\n    @property\n    def value_type(self):\n\"\"\"Value type of the source field.\"\"\"\n        return self._value_type\n\n    @property  # type: ignore\n    def stream_name(self) -&gt; str:\n        if self.source_obj:\n            return f'{SPECIAL_CHAR}{self.source_obj.pybrook_options.name}{SPECIAL_CHAR}split'\n        return f'{SPECIAL_CHAR}artificial{SPECIAL_CHAR}{self.field_name}'\n\n    def __repr__(self):\n        return f'&lt;{self.__class__.__name__} name={self.field_name},' \\\n               f' report_class={self.source_obj.__name__ if self.source_obj else \"artificial\"},' \\\n               f' value_type={self.value_type.__name__}&gt;'\n</code></pre>"},{"location":"reference/models.html#pybrook.models.SourceField._value_type","title":"<code>_value_type: Type = value_type</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.SourceField.field_name","title":"<code>field_name: str = field_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.SourceField.source_obj","title":"<code>source_obj: Optional[Type[InReport]] = source_obj</code>  <code>instance-attribute</code>","text":""},{"location":"reference/models.html#pybrook.models.SourceField.stream_name","title":"<code>stream_name: str</code>  <code>property</code>","text":""},{"location":"reference/models.html#pybrook.models.SourceField.value_type","title":"<code>value_type</code>  <code>property</code>","text":"<p>Value type of the source field.</p>"},{"location":"reference/models.html#pybrook.models.SourceField.__init__","title":"<code>__init__(field_name, *, value_type, source_obj=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>value_type</code> <code>Type</code> <p>Field value type.</p> required <code>field_name</code> <code>str</code> <p>Source field.</p> required <code>source_obj</code> <code>Type[InReport]</code> <p>InReport that the field belongs to.</p> <code>None</code> Source code in <code>pybrook/models.py</code> <pre><code>def __init__(self,\n             field_name: str,\n             *,\n             value_type: Type,\n             source_obj: Type['InReport'] = None):\n\"\"\"\n    Args:\n        value_type: Field value type.\n        field_name: Source field.\n        source_obj: InReport that the field belongs to.\n    \"\"\"\n    self.field_name: str = field_name\n    self.source_obj: Optional[Type[InReport]] = source_obj\n    self._value_type: Type = value_type\n</code></pre>"},{"location":"reference/models.html#pybrook.models.SourceField.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pybrook/models.py</code> <pre><code>def __repr__(self):\n    return f'&lt;{self.__class__.__name__} name={self.field_name},' \\\n           f' report_class={self.source_obj.__name__ if self.source_obj else \"artificial\"},' \\\n           f' value_type={self.value_type.__name__}&gt;'\n</code></pre>"},{"location":"reference/models.html#pybrook.models.dependency","title":"<code>dependency(src)</code>","text":"<p>Depending on <code>src</code>, the injected dependency will be value of some field (artificial or loaded from report) or a Redis instance.</p> <p>See Dependency for implementation details.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>DTYPE</code> <p>Target of the dependency.  Should be an instance of SourceField  or a Redis class (<code>aioredis.Redis</code> or <code>redis.Redis</code>).</p> required <p>Returns:</p> Type Description <code>DTYPE</code> <p>A HistoricalDependency,</p> <code>DTYPE</code> <p>but mypy is made to believe that the type the returned value is src.value_type.</p> Source code in <code>pybrook/models.py</code> <pre><code>def dependency(src: DTYPE) -&gt; DTYPE:\n\"\"\"\n    Depending on `src`, the injected dependency will be value of some field (artificial or loaded from report)\n    or a Redis instance.\n\n    See [Dependency][pybrook.models.Dependency] for implementation details.\n\n    Args:\n        src: Target of the dependency.\n             Should be an instance of [SourceField][pybrook.models.SourceField]\n             or a Redis class (`aioredis.Redis` or `redis.Redis`).\n    Returns:\n         A [HistoricalDependency][pybrook.models.HistoricalDependency],\n         but mypy is made to believe that the type the returned value is [src.value_type][pybrook.models.SourceField.value_type].\n    \"\"\"\n    dep: DTYPE\n    dep = Dependency(src)  # type: ignore\n    return dep  # noqa: WPS331\n</code></pre>"},{"location":"reference/models.html#pybrook.models.historical_dependency","title":"<code>historical_dependency(src, history_length)</code>","text":"<p>See HistoricalDependency for implementation details.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>DTYPE</code> <p>Target of the dependency.  Should be an instance of SourceField.  You can also reference artificial fields by passing their name,  which is useful for recursive dependencies.</p> required <p>Returns:</p> Type Description <code>Sequence[DTYPE]</code> <p>A HistoricalDependency,</p> <code>Sequence[DTYPE]</code> <p>but mypy is made to believe that it's a sequence containing items</p> <code>Sequence[DTYPE]</code> <p>of type of the corresponding SourceField.</p> Source code in <code>pybrook/models.py</code> <pre><code>def historical_dependency(src: DTYPE, history_length: int) -&gt; Sequence[DTYPE]:\n\"\"\"\n    See [HistoricalDependency][pybrook.models.HistoricalDependency] for implementation details.\n\n    Args:\n        src: Target of the dependency.\n             Should be an instance of [SourceField][pybrook.models.SourceField].\n             You can also reference artificial fields by passing their name,\n             which is useful for recursive dependencies.\n    Returns:\n        A [HistoricalDependency][pybrook.models.HistoricalDependency],\n        but mypy is made to believe that it's a sequence containing items\n        of type of the corresponding [SourceField][pybrook.models.SourceField].\n    \"\"\"\n    dep: Sequence[DTYPE]\n    dep = HistoricalDependency(  # type: ignore\n        src,  # type: ignore\n        history_length=history_length)\n    return dep  # noqa: WPS331\n</code></pre>"},{"location":"reference/schemas.html","title":"schemas","text":"<p>This module contains definitions of Pydantic models used to tell the frontend about available streams &amp; fields.</p> <p>This is required, because the OpenAPI documentation doesn't support WebSockets.</p>"},{"location":"reference/schemas.html#pybrook.schemas.FieldInfo","title":"<code>FieldInfo</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>pybrook/schemas.py</code> <pre><code>class FieldInfo(BaseModel):\n    stream_name: str\n    field_name: str\n</code></pre>"},{"location":"reference/schemas.html#pybrook.schemas.FieldInfo.field_name","title":"<code>field_name: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/schemas.html#pybrook.schemas.FieldInfo.stream_name","title":"<code>stream_name: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/schemas.html#pybrook.schemas.PyBrookSchema","title":"<code>PyBrookSchema</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>pybrook/schemas.py</code> <pre><code>class PyBrookSchema(BaseModel):\n    streams: List[StreamInfo] = []\n    special_char: str = SPECIAL_CHAR\n    msg_id_field: str = MSG_ID_FIELD\n    latitude_field: Optional[FieldInfo] = None\n    longitude_field: Optional[FieldInfo] = None\n    time_field: Optional[FieldInfo] = None\n    group_field: Optional[FieldInfo] = None\n    direction_field: Optional[FieldInfo] = None\n</code></pre>"},{"location":"reference/schemas.html#pybrook.schemas.PyBrookSchema.direction_field","title":"<code>direction_field: Optional[FieldInfo] = None</code>  <code>class-attribute</code>","text":""},{"location":"reference/schemas.html#pybrook.schemas.PyBrookSchema.group_field","title":"<code>group_field: Optional[FieldInfo] = None</code>  <code>class-attribute</code>","text":""},{"location":"reference/schemas.html#pybrook.schemas.PyBrookSchema.latitude_field","title":"<code>latitude_field: Optional[FieldInfo] = None</code>  <code>class-attribute</code>","text":""},{"location":"reference/schemas.html#pybrook.schemas.PyBrookSchema.longitude_field","title":"<code>longitude_field: Optional[FieldInfo] = None</code>  <code>class-attribute</code>","text":""},{"location":"reference/schemas.html#pybrook.schemas.PyBrookSchema.msg_id_field","title":"<code>msg_id_field: str = MSG_ID_FIELD</code>  <code>class-attribute</code>","text":""},{"location":"reference/schemas.html#pybrook.schemas.PyBrookSchema.special_char","title":"<code>special_char: str = SPECIAL_CHAR</code>  <code>class-attribute</code>","text":""},{"location":"reference/schemas.html#pybrook.schemas.PyBrookSchema.streams","title":"<code>streams: List[StreamInfo] = []</code>  <code>class-attribute</code>","text":""},{"location":"reference/schemas.html#pybrook.schemas.PyBrookSchema.time_field","title":"<code>time_field: Optional[FieldInfo] = None</code>  <code>class-attribute</code>","text":""},{"location":"reference/schemas.html#pybrook.schemas.StreamInfo","title":"<code>StreamInfo</code>","text":"<p>         Bases: <code>BaseModel</code></p> Source code in <code>pybrook/schemas.py</code> <pre><code>class StreamInfo(BaseModel):\n    stream_name: str\n    websocket_path: str\n    report_schema: Dict[Any, Any]\n</code></pre>"},{"location":"reference/schemas.html#pybrook.schemas.StreamInfo.report_schema","title":"<code>report_schema: Dict[Any, Any]</code>  <code>class-attribute</code>","text":""},{"location":"reference/schemas.html#pybrook.schemas.StreamInfo.stream_name","title":"<code>stream_name: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/schemas.html#pybrook.schemas.StreamInfo.websocket_path","title":"<code>websocket_path: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/consumers/base.html","title":"base","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.CONSUMER_NAME_LENGTH","title":"<code>CONSUMER_NAME_LENGTH = 64</code>  <code>module-attribute</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.AsyncStreamConsumer","title":"<code>AsyncStreamConsumer</code>","text":"<p>         Bases: <code>BaseStreamConsumer</code></p> Source code in <code>pybrook/consumers/base.py</code> <pre><code>class AsyncStreamConsumer(BaseStreamConsumer):\n    async def process_message_async(\n            self, stream_name: str, message: Dict[str, str], *,\n            redis_conn: aioredis.Redis,\n            pipeline: aioredis.client.Pipeline) -&gt; Dict[str, Dict[str, str]]:\n        raise NotImplementedError(  # pragma: nocover\n            f'Async version of process_message for {type(self).__name__} not implemented.'\n        )\n\n    @property\n    def supported_impl(self) -&gt; Set[ConsumerImpl]:\n        return super().supported_impl | {ConsumerImpl.ASYNC}\n\n    def stop(self, signum=None, frame=None):\n        super().stop(signum, frame)\n        if asyncio.all_tasks():\n            logger.info(\n                'Waiting for all asyncio tasks to finish, use Ctrl + C to force exit.'\n            )\n\n    async def run_async(self):  # noqa: WPS231\n        self.register_signals()\n        redis_conn: aioredis.Redis = await aioredis.from_url(\n            self.redis_url, encoding='utf-8', decode_responses=True)\n        self.active = True\n        xreadgroup_params = self._xreadgroup_params\n        tasks: Set[asyncio.Future] = set()\n        while self.active:\n            response = await redis_conn.xreadgroup(**xreadgroup_params)\n            for stream, messages in response:\n                for msg_id, payload in messages:\n                    tasks.add(\n                        asyncio.create_task(\n                            self._handle_message_async(stream, msg_id, payload,\n                                                       redis_conn)))\n            for num, task in enumerate(asyncio.as_completed(tasks)):\n                await task\n                if num &gt; self._read_chunk_length / 2 or not self.active:\n                    done, tasks = await asyncio.wait(\n                        tasks, return_when=asyncio.FIRST_COMPLETED)\n                    xreadgroup_params['count'] = self._read_chunk_length - len(\n                        tasks)\n                    break\n        await redis_conn.close()\n\n    async def _handle_message_async(self, stream: str, msg_id: str,\n                                    payload: Dict[str, str],\n                                    redis_conn: aioredis.Redis):\n        async with redis_conn.pipeline() as p:\n            result = await self.process_message_async(stream,\n                                                      payload,\n                                                      redis_conn=redis_conn,\n                                                      pipeline=p)\n            for out_stream, out_msg in result.items():\n                p.xadd(out_stream, out_msg)  # type: ignore\n            p.xack(stream, self.consumer_group_name, msg_id)\n            try:\n                await p.execute()\n            except aioredis.WatchError:  # pragma: nocover\n                await redis_conn.xack(stream, self.consumer_group_name, msg_id)\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.AsyncStreamConsumer.supported_impl","title":"<code>supported_impl: Set[ConsumerImpl]</code>  <code>property</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.AsyncStreamConsumer._handle_message_async","title":"<code>_handle_message_async(stream, msg_id, payload, redis_conn)</code>  <code>async</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>async def _handle_message_async(self, stream: str, msg_id: str,\n                                payload: Dict[str, str],\n                                redis_conn: aioredis.Redis):\n    async with redis_conn.pipeline() as p:\n        result = await self.process_message_async(stream,\n                                                  payload,\n                                                  redis_conn=redis_conn,\n                                                  pipeline=p)\n        for out_stream, out_msg in result.items():\n            p.xadd(out_stream, out_msg)  # type: ignore\n        p.xack(stream, self.consumer_group_name, msg_id)\n        try:\n            await p.execute()\n        except aioredis.WatchError:  # pragma: nocover\n            await redis_conn.xack(stream, self.consumer_group_name, msg_id)\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.AsyncStreamConsumer.process_message_async","title":"<code>process_message_async(stream_name, message, *, redis_conn, pipeline)</code>  <code>async</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>async def process_message_async(\n        self, stream_name: str, message: Dict[str, str], *,\n        redis_conn: aioredis.Redis,\n        pipeline: aioredis.client.Pipeline) -&gt; Dict[str, Dict[str, str]]:\n    raise NotImplementedError(  # pragma: nocover\n        f'Async version of process_message for {type(self).__name__} not implemented.'\n    )\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.AsyncStreamConsumer.run_async","title":"<code>run_async()</code>  <code>async</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>async def run_async(self):  # noqa: WPS231\n    self.register_signals()\n    redis_conn: aioredis.Redis = await aioredis.from_url(\n        self.redis_url, encoding='utf-8', decode_responses=True)\n    self.active = True\n    xreadgroup_params = self._xreadgroup_params\n    tasks: Set[asyncio.Future] = set()\n    while self.active:\n        response = await redis_conn.xreadgroup(**xreadgroup_params)\n        for stream, messages in response:\n            for msg_id, payload in messages:\n                tasks.add(\n                    asyncio.create_task(\n                        self._handle_message_async(stream, msg_id, payload,\n                                                   redis_conn)))\n        for num, task in enumerate(asyncio.as_completed(tasks)):\n            await task\n            if num &gt; self._read_chunk_length / 2 or not self.active:\n                done, tasks = await asyncio.wait(\n                    tasks, return_when=asyncio.FIRST_COMPLETED)\n                xreadgroup_params['count'] = self._read_chunk_length - len(\n                    tasks)\n                break\n    await redis_conn.close()\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.AsyncStreamConsumer.stop","title":"<code>stop(signum=None, frame=None)</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def stop(self, signum=None, frame=None):\n    super().stop(signum, frame)\n    if asyncio.all_tasks():\n        logger.info(\n            'Waiting for all asyncio tasks to finish, use Ctrl + C to force exit.'\n        )\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer","title":"<code>BaseStreamConsumer</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>class BaseStreamConsumer:\n    def __init__(self,\n                 *,\n                 redis_url: str,\n                 consumer_group_name: str,\n                 input_streams: Iterable[str],\n                 use_thread_executor: bool = False,\n                 read_chunk_length: int = 1,\n                 read_messages_since: Union[str, int] = '$'):\n        self.consumer_group_name = consumer_group_name\n        self.redis_url = redis_url\n        self._active = False\n        self._use_thread_executor = use_thread_executor\n        self._read_chunk_length = read_chunk_length\n        self.executor = None\n        self.input_streams = tuple(input_streams)\n        if not re.match(r'\\$|\\d+(?:-\\d+)?', str(read_messages_since)):\n            raise ValueError(\n                'read_messages_since should be a positive integer or $!')\n        self.read_messages_since = str(read_messages_since)\n\n    @property\n    def supported_impl(self) -&gt; Set[ConsumerImpl]:\n        return set()  # pragma: nocover\n\n    def __repr__(self):\n        return f'&lt;{self.__class__.__name__} input_streams={self.input_streams}&gt;'\n\n    @property\n    def input_streams(self) -&gt; Tuple[str, ...]:\n        return tuple(self._input_streams)\n\n    @input_streams.setter\n    def input_streams(self, streams: Tuple[str, ...]):\n        self._input_streams = tuple(streams)\n\n    def register_consumer(self):\n        redis_conn = redis.from_url(self.redis_url,\n                                    encoding='utf-8',\n                                    decode_responses=True)\n        for stream in self.input_streams:\n            try:\n                redis_conn.xgroup_create(stream,\n                                         self.consumer_group_name,\n                                         id=self.read_messages_since,\n                                         mkstream=True)\n            except redis.ResponseError as e:\n                if 'BUSYGROUP' not in str(e):\n                    raise e  # pragma: nocover\n\n    def stop(self, signum=None, frame=None):\n        if not self._active:\n            logger.warning(f'Killing {self}')\n            sys.exit()\n        logger.info(f'Terminating {self}')\n        self.active = False\n\n    def register_signals(self):\n        signal.signal(signal.SIGTERM, self.stop)\n        signal.signal(signal.SIGINT, self.stop)\n\n    @property\n    def active(self):\n        return self._active\n\n    @active.setter\n    def active(self, value: bool):\n        self._active = value\n\n    @property\n    def _xreadgroup_params(self) -&gt; MutableMapping:\n        consumer_name = secrets.token_urlsafe(CONSUMER_NAME_LENGTH)\n        return {\n            'streams': {s: '&gt;'\n                        for s in self.input_streams},\n            'groupname': self.consumer_group_name,\n            'consumername': consumer_name,\n            'count': self._read_chunk_length,\n            'block': 1000\n        }\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer._active","title":"<code>_active = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer._read_chunk_length","title":"<code>_read_chunk_length = read_chunk_length</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer._use_thread_executor","title":"<code>_use_thread_executor = use_thread_executor</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer._xreadgroup_params","title":"<code>_xreadgroup_params: MutableMapping</code>  <code>property</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.active","title":"<code>active</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.consumer_group_name","title":"<code>consumer_group_name = consumer_group_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.executor","title":"<code>executor = None</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.input_streams","title":"<code>input_streams: Tuple[str, ...]</code>  <code>property</code> <code>writable</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.read_messages_since","title":"<code>read_messages_since = str(read_messages_since)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.redis_url","title":"<code>redis_url = redis_url</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.supported_impl","title":"<code>supported_impl: Set[ConsumerImpl]</code>  <code>property</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.__init__","title":"<code>__init__(*, redis_url, consumer_group_name, input_streams, use_thread_executor=False, read_chunk_length=1, read_messages_since='$')</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def __init__(self,\n             *,\n             redis_url: str,\n             consumer_group_name: str,\n             input_streams: Iterable[str],\n             use_thread_executor: bool = False,\n             read_chunk_length: int = 1,\n             read_messages_since: Union[str, int] = '$'):\n    self.consumer_group_name = consumer_group_name\n    self.redis_url = redis_url\n    self._active = False\n    self._use_thread_executor = use_thread_executor\n    self._read_chunk_length = read_chunk_length\n    self.executor = None\n    self.input_streams = tuple(input_streams)\n    if not re.match(r'\\$|\\d+(?:-\\d+)?', str(read_messages_since)):\n        raise ValueError(\n            'read_messages_since should be a positive integer or $!')\n    self.read_messages_since = str(read_messages_since)\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def __repr__(self):\n    return f'&lt;{self.__class__.__name__} input_streams={self.input_streams}&gt;'\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.register_consumer","title":"<code>register_consumer()</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def register_consumer(self):\n    redis_conn = redis.from_url(self.redis_url,\n                                encoding='utf-8',\n                                decode_responses=True)\n    for stream in self.input_streams:\n        try:\n            redis_conn.xgroup_create(stream,\n                                     self.consumer_group_name,\n                                     id=self.read_messages_since,\n                                     mkstream=True)\n        except redis.ResponseError as e:\n            if 'BUSYGROUP' not in str(e):\n                raise e  # pragma: nocover\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.register_signals","title":"<code>register_signals()</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def register_signals(self):\n    signal.signal(signal.SIGTERM, self.stop)\n    signal.signal(signal.SIGINT, self.stop)\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.BaseStreamConsumer.stop","title":"<code>stop(signum=None, frame=None)</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def stop(self, signum=None, frame=None):\n    if not self._active:\n        logger.warning(f'Killing {self}')\n        sys.exit()\n    logger.info(f'Terminating {self}')\n    self.active = False\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.ConsumerImpl","title":"<code>ConsumerImpl</code>","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>pybrook/consumers/base.py</code> <pre><code>class ConsumerImpl(Enum):\n    GEARS = 'GEARS'\n    ASYNC = 'ASYNC'\n    SYNC = 'SYNC'\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.ConsumerImpl.ASYNC","title":"<code>ASYNC = 'ASYNC'</code>  <code>class-attribute</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.ConsumerImpl.GEARS","title":"<code>GEARS = 'GEARS'</code>  <code>class-attribute</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.ConsumerImpl.SYNC","title":"<code>SYNC = 'SYNC'</code>  <code>class-attribute</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.GearsStreamConsumer","title":"<code>GearsStreamConsumer</code>","text":"<p>         Bases: <code>BaseStreamConsumer</code></p> Source code in <code>pybrook/consumers/base.py</code> <pre><code>class GearsStreamConsumer(BaseStreamConsumer):\n    @property\n    def supported_impl(self) -&gt; Set[ConsumerImpl]:\n        return super().supported_impl | {ConsumerImpl.GEARS}\n\n    def register_builder(self, conn: redis.Redis):\n        raise NotImplementedError  # pragma: nocover\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.GearsStreamConsumer.supported_impl","title":"<code>supported_impl: Set[ConsumerImpl]</code>  <code>property</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.GearsStreamConsumer.register_builder","title":"<code>register_builder(conn)</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def register_builder(self, conn: redis.Redis):\n    raise NotImplementedError  # pragma: nocover\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.SyncStreamConsumer","title":"<code>SyncStreamConsumer</code>","text":"<p>         Bases: <code>BaseStreamConsumer</code></p> Source code in <code>pybrook/consumers/base.py</code> <pre><code>class SyncStreamConsumer(BaseStreamConsumer):\n    def process_message_sync(\n            self, stream_name: str, message: Dict[str, str], *,\n            redis_conn: redis.Redis,\n            pipeline: redis.client.Pipeline) -&gt; Dict[str, Dict[str, str]]:\n        raise NotImplementedError(  # pragma: nocover\n            f'Sync version of process_message for {type(self).__name__} not implemented.'\n        )\n\n    @property\n    def supported_impl(self) -&gt; Set[ConsumerImpl]:\n        return super().supported_impl | {ConsumerImpl.SYNC}\n\n    def stop(self, signum=None, frame=None):\n        super().stop(signum, frame)\n        if not self.executor:\n            return\n        self.executor.shutdown(wait=False, cancel_futures=False)\n        if self.executor._work_queue.qsize():  # noqa: WPS437\n            logger.warning(\n                'Waiting for all futures to finish, use Ctrl + C to force exit.'\n            )\n\n    def run_sync(self):  # noqa: WPS231\n        self.register_signals()\n        redis_conn: redis.Redis = redis.from_url(self.redis_url,\n                                                 encoding='utf-8',\n                                                 decode_responses=True)\n        self._active = True\n        xreadgroup_params = self._xreadgroup_params\n        if self._use_thread_executor:\n            self.executor = futures.ThreadPoolExecutor(\n                max_workers=self._read_chunk_length\n            )  # TODO: Parametrize max_workers\n        tasks: Set[futures.Future] = set()\n        while self.active:\n            response = redis_conn.xreadgroup(**xreadgroup_params)\n            for stream, messages in response:\n                for msg_id, payload in messages:\n                    if self._use_thread_executor:\n                        tasks.add(\n                            self.executor.submit(self._handle_message_sync,\n                                                 stream, msg_id, payload,\n                                                 redis_conn))\n                    else:\n                        self._handle_message_sync(stream, msg_id, payload,\n                                                  redis_conn)\n                if self._use_thread_executor:\n                    for num, task in enumerate(futures.as_completed(tasks)):\n                        task.result()\n                        if num &gt; self._read_chunk_length / 2 or not self.active:\n                            done, tasks = futures.wait(\n                                tasks, return_when=asyncio.FIRST_COMPLETED)\n                            xreadgroup_params[\n                                'count'] = self._read_chunk_length - len(tasks)\n                            break\n        redis_conn.close()\n\n    def _handle_message_sync(self, stream: str, msg_id: str,\n                             payload: Dict[str, str], redis_conn: redis.Redis):\n        with redis_conn.pipeline() as p:\n            result = self.process_message_sync(stream,\n                                               payload,\n                                               redis_conn=redis_conn,\n                                               pipeline=p)\n            for out_stream, out_msg in result.items():\n                p.xadd(out_stream, out_msg)\n            p.xack(stream, self.consumer_group_name, msg_id)\n            try:\n                p.execute()\n            except redis.WatchError:  # pragma: nocover\n                redis_conn.xack(stream, self.consumer_group_name, msg_id)\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.SyncStreamConsumer.supported_impl","title":"<code>supported_impl: Set[ConsumerImpl]</code>  <code>property</code>","text":""},{"location":"reference/consumers/base.html#pybrook.consumers.base.SyncStreamConsumer._handle_message_sync","title":"<code>_handle_message_sync(stream, msg_id, payload, redis_conn)</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def _handle_message_sync(self, stream: str, msg_id: str,\n                         payload: Dict[str, str], redis_conn: redis.Redis):\n    with redis_conn.pipeline() as p:\n        result = self.process_message_sync(stream,\n                                           payload,\n                                           redis_conn=redis_conn,\n                                           pipeline=p)\n        for out_stream, out_msg in result.items():\n            p.xadd(out_stream, out_msg)\n        p.xack(stream, self.consumer_group_name, msg_id)\n        try:\n            p.execute()\n        except redis.WatchError:  # pragma: nocover\n            redis_conn.xack(stream, self.consumer_group_name, msg_id)\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.SyncStreamConsumer.process_message_sync","title":"<code>process_message_sync(stream_name, message, *, redis_conn, pipeline)</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def process_message_sync(\n        self, stream_name: str, message: Dict[str, str], *,\n        redis_conn: redis.Redis,\n        pipeline: redis.client.Pipeline) -&gt; Dict[str, Dict[str, str]]:\n    raise NotImplementedError(  # pragma: nocover\n        f'Sync version of process_message for {type(self).__name__} not implemented.'\n    )\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.SyncStreamConsumer.run_sync","title":"<code>run_sync()</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def run_sync(self):  # noqa: WPS231\n    self.register_signals()\n    redis_conn: redis.Redis = redis.from_url(self.redis_url,\n                                             encoding='utf-8',\n                                             decode_responses=True)\n    self._active = True\n    xreadgroup_params = self._xreadgroup_params\n    if self._use_thread_executor:\n        self.executor = futures.ThreadPoolExecutor(\n            max_workers=self._read_chunk_length\n        )  # TODO: Parametrize max_workers\n    tasks: Set[futures.Future] = set()\n    while self.active:\n        response = redis_conn.xreadgroup(**xreadgroup_params)\n        for stream, messages in response:\n            for msg_id, payload in messages:\n                if self._use_thread_executor:\n                    tasks.add(\n                        self.executor.submit(self._handle_message_sync,\n                                             stream, msg_id, payload,\n                                             redis_conn))\n                else:\n                    self._handle_message_sync(stream, msg_id, payload,\n                                              redis_conn)\n            if self._use_thread_executor:\n                for num, task in enumerate(futures.as_completed(tasks)):\n                    task.result()\n                    if num &gt; self._read_chunk_length / 2 or not self.active:\n                        done, tasks = futures.wait(\n                            tasks, return_when=asyncio.FIRST_COMPLETED)\n                        xreadgroup_params[\n                            'count'] = self._read_chunk_length - len(tasks)\n                        break\n    redis_conn.close()\n</code></pre>"},{"location":"reference/consumers/base.html#pybrook.consumers.base.SyncStreamConsumer.stop","title":"<code>stop(signum=None, frame=None)</code>","text":"Source code in <code>pybrook/consumers/base.py</code> <pre><code>def stop(self, signum=None, frame=None):\n    super().stop(signum, frame)\n    if not self.executor:\n        return\n    self.executor.shutdown(wait=False, cancel_futures=False)\n    if self.executor._work_queue.qsize():  # noqa: WPS437\n        logger.warning(\n            'Waiting for all futures to finish, use Ctrl + C to force exit.'\n        )\n</code></pre>"},{"location":"reference/consumers/dependency_resolver.html","title":"dependency_resolver","text":""},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver","title":"<code>DependencyResolver</code>","text":"<p>         Bases: <code>SyncStreamConsumer</code></p> Source code in <code>pybrook/consumers/dependency_resolver.py</code> <pre><code>class DependencyResolver(SyncStreamConsumer):\n    @dataclasses.dataclass\n    class Dep:  # noqa: WPS431\n        src_stream: str\n        src_key: str\n        dst_key: str\n\n    @dataclasses.dataclass\n    class HistoricalDep:  # noqa: WPS431\n        src_stream: str\n        src_key: str\n        dst_key: str\n        history_length: int = 1\n\n    def __init__(self,\n                 *,\n                 redis_url: str,\n                 resolver_name: str,\n                 output_stream_name: str = None,\n                 dependencies: List[Dep],\n                 historical_dependencies: List[HistoricalDep] = None,\n                 read_chunk_length: int = 100,\n                 **kwargs):\n\"\"\"\n\n        Args:\n            redis_url: Redis server URL\n            resolver_name: Name of the resolver, used for the consumer group\n            output_stream_name: name of the output stream\n            historical_dependencies:\n                A list of historical dependencies to load when all regular dependencies are available.\n            dependencies:\n                Keys are source streams, values are dependency names used as keys in the output stream.\n                Source streams should contain just the internal msgid and values\n                for the specific field.\n            read_chunk_length: Redis XACK COUNT arg\n            kwargs: other arguments that will be passed to SyncStreamConsumer.__init__\n        \"\"\"\n        self._dependencies: List[DependencyResolver.Dep] = dependencies\n        self._historical_dependencies: List[\n            DependencyResolver.HistoricalDep] = historical_dependencies or []\n        self._num_dependencies = len(dependencies)\n        consumer_group_name = f'{resolver_name}{SPECIAL_CHAR}dr'\n        if not output_stream_name:\n            output_stream_name = f'{SPECIAL_CHAR}{consumer_group_name}{SPECIAL_CHAR}deps'\n        self.output_stream_name: str = output_stream_name\n        input_streams = list({\n            s.src_stream  # type: ignore\n            for s in chain(dependencies, self._historical_dependencies)\n        })\n        super().__init__(redis_url=redis_url,\n                         consumer_group_name=consumer_group_name,\n                         input_streams=input_streams,\n                         read_chunk_length=read_chunk_length,\n                         **kwargs)\n\n    def __repr__(self):\n        return f'&lt;{self.__class__.__name__} output_stream_name=\\'{self.output_stream_name}\\'' \\\n               f' input_streams={self.input_streams}, dependencies={self._dependencies}&gt;'\n\n    def dependency_map_key(self, message_id: str):\n        return f'{SPECIAL_CHAR}depmap{self.output_stream_name}{SPECIAL_CHAR}{message_id}'\n\n    def send_historical_deps(self, message_id: str, message: Dict[str, str],\n                             pipeline: redis.client.Pipeline):\n        historical_deps = [(k.dst_key, message[k.src_key], k.history_length)\n                           for k in self._historical_dependencies\n                           if k.src_key in message]\n        if historical_deps:\n            vehicle_id, vehicle_message_id = message_id.rsplit(SPECIAL_CHAR,\n                                                               maxsplit=1)\n            dependency_map_key_base = self.dependency_map_key(vehicle_id\n                                                              + SPECIAL_CHAR)\n            for dst_key, value, history_length in historical_deps:\n                id_in_deps = history_length\n                future_vehicle_message_id = int(vehicle_message_id)\n                while id_in_deps &gt; 0:\n                    id_in_deps -= 1\n                    future_vehicle_message_id += 1\n                    pipeline.hset(\n                        f'{dependency_map_key_base}{future_vehicle_message_id}',\n                        f'{dst_key}{SPECIAL_CHAR}{id_in_deps}', value)\n\n    def process_message_sync(\n            self, stream_name: str, message: Dict[str, str], *,\n            redis_conn: redis.Redis,\n            pipeline: redis.client.Pipeline) -&gt; Dict[str, Dict[str, str]]:\n        message_id_enc = message.pop(MSG_ID_FIELD)\n        message_id = decode_value(message_id_enc)\n        dep_key = self.dependency_map_key(message_id)\n        incr_key = dep_key + f'{SPECIAL_CHAR}incr'\n        new_deps = {\n            k.dst_key: message[k.src_key]\n            for k in self._dependencies\n            if k.src_key in message\n        }\n        incr_num = 0\n        if new_deps:\n            with redis_conn.pipeline() as p:\n                p.multi()\n                p.hset(dep_key, mapping=new_deps)  # type: ignore\n                p.incrby(incr_key, len(new_deps))\n                _, incr_num = p.execute()\n        if self._historical_dependencies:\n            self.send_historical_deps(message_id, message, pipeline)\n        if incr_num == self._num_dependencies:\n            dependencies = redis_conn.hgetall(dep_key)\n            for h in self._historical_dependencies:\n                dependencies[h.dst_key] = []\n                for i in range(h.history_length):\n                    dep_value = dependencies.pop(\n                        f'{h.dst_key}{SPECIAL_CHAR}{i}', None)\n                    dependencies[h.dst_key].append(\n                        decode_value(dep_value\n                                     ) if dep_value is not None else dep_value)\n                dependencies[h.dst_key] = encode_value(dependencies[h.dst_key])\n            # tutaj by\u0142a transakcja\n            pipeline.delete(dep_key, incr_key)\n            return {\n                self.output_stream_name: {\n                    MSG_ID_FIELD: message_id_enc,\n                    **dependencies\n                }\n            }\n        return {}\n</code></pre>"},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver._dependencies","title":"<code>_dependencies: List[DependencyResolver.Dep] = dependencies</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver._historical_dependencies","title":"<code>_historical_dependencies: List[DependencyResolver.HistoricalDep] = historical_dependencies or []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver._num_dependencies","title":"<code>_num_dependencies = len(dependencies)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver.output_stream_name","title":"<code>output_stream_name: str = output_stream_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver.Dep","title":"<code>Dep</code>  <code>dataclass</code>","text":"Source code in <code>pybrook/consumers/dependency_resolver.py</code> <pre><code>@dataclasses.dataclass\nclass Dep:  # noqa: WPS431\n    src_stream: str\n    src_key: str\n    dst_key: str\n</code></pre>"},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver.Dep.dst_key","title":"<code>dst_key: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver.Dep.src_key","title":"<code>src_key: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver.Dep.src_stream","title":"<code>src_stream: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver.HistoricalDep","title":"<code>HistoricalDep</code>  <code>dataclass</code>","text":"Source code in <code>pybrook/consumers/dependency_resolver.py</code> <pre><code>@dataclasses.dataclass\nclass HistoricalDep:  # noqa: WPS431\n    src_stream: str\n    src_key: str\n    dst_key: str\n    history_length: int = 1\n</code></pre>"},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver.HistoricalDep.dst_key","title":"<code>dst_key: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver.HistoricalDep.history_length","title":"<code>history_length: int = 1</code>  <code>class-attribute</code>","text":""},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver.HistoricalDep.src_key","title":"<code>src_key: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver.HistoricalDep.src_stream","title":"<code>src_stream: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver.__init__","title":"<code>__init__(*, redis_url, resolver_name, output_stream_name=None, dependencies, historical_dependencies=None, read_chunk_length=100, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>redis_url</code> <code>str</code> <p>Redis server URL</p> required <code>resolver_name</code> <code>str</code> <p>Name of the resolver, used for the consumer group</p> required <code>output_stream_name</code> <code>str</code> <p>name of the output stream</p> <code>None</code> <code>historical_dependencies</code> <code>List[HistoricalDep]</code> <p>A list of historical dependencies to load when all regular dependencies are available.</p> <code>None</code> <code>dependencies</code> <code>List[Dep]</code> <p>Keys are source streams, values are dependency names used as keys in the output stream. Source streams should contain just the internal msgid and values for the specific field.</p> required <code>read_chunk_length</code> <code>int</code> <p>Redis XACK COUNT arg</p> <code>100</code> <code>kwargs</code> <p>other arguments that will be passed to SyncStreamConsumer.init</p> <code>{}</code> Source code in <code>pybrook/consumers/dependency_resolver.py</code> <pre><code>def __init__(self,\n             *,\n             redis_url: str,\n             resolver_name: str,\n             output_stream_name: str = None,\n             dependencies: List[Dep],\n             historical_dependencies: List[HistoricalDep] = None,\n             read_chunk_length: int = 100,\n             **kwargs):\n\"\"\"\n\n    Args:\n        redis_url: Redis server URL\n        resolver_name: Name of the resolver, used for the consumer group\n        output_stream_name: name of the output stream\n        historical_dependencies:\n            A list of historical dependencies to load when all regular dependencies are available.\n        dependencies:\n            Keys are source streams, values are dependency names used as keys in the output stream.\n            Source streams should contain just the internal msgid and values\n            for the specific field.\n        read_chunk_length: Redis XACK COUNT arg\n        kwargs: other arguments that will be passed to SyncStreamConsumer.__init__\n    \"\"\"\n    self._dependencies: List[DependencyResolver.Dep] = dependencies\n    self._historical_dependencies: List[\n        DependencyResolver.HistoricalDep] = historical_dependencies or []\n    self._num_dependencies = len(dependencies)\n    consumer_group_name = f'{resolver_name}{SPECIAL_CHAR}dr'\n    if not output_stream_name:\n        output_stream_name = f'{SPECIAL_CHAR}{consumer_group_name}{SPECIAL_CHAR}deps'\n    self.output_stream_name: str = output_stream_name\n    input_streams = list({\n        s.src_stream  # type: ignore\n        for s in chain(dependencies, self._historical_dependencies)\n    })\n    super().__init__(redis_url=redis_url,\n                     consumer_group_name=consumer_group_name,\n                     input_streams=input_streams,\n                     read_chunk_length=read_chunk_length,\n                     **kwargs)\n</code></pre>"},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pybrook/consumers/dependency_resolver.py</code> <pre><code>def __repr__(self):\n    return f'&lt;{self.__class__.__name__} output_stream_name=\\'{self.output_stream_name}\\'' \\\n           f' input_streams={self.input_streams}, dependencies={self._dependencies}&gt;'\n</code></pre>"},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver.dependency_map_key","title":"<code>dependency_map_key(message_id)</code>","text":"Source code in <code>pybrook/consumers/dependency_resolver.py</code> <pre><code>def dependency_map_key(self, message_id: str):\n    return f'{SPECIAL_CHAR}depmap{self.output_stream_name}{SPECIAL_CHAR}{message_id}'\n</code></pre>"},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver.process_message_sync","title":"<code>process_message_sync(stream_name, message, *, redis_conn, pipeline)</code>","text":"Source code in <code>pybrook/consumers/dependency_resolver.py</code> <pre><code>def process_message_sync(\n        self, stream_name: str, message: Dict[str, str], *,\n        redis_conn: redis.Redis,\n        pipeline: redis.client.Pipeline) -&gt; Dict[str, Dict[str, str]]:\n    message_id_enc = message.pop(MSG_ID_FIELD)\n    message_id = decode_value(message_id_enc)\n    dep_key = self.dependency_map_key(message_id)\n    incr_key = dep_key + f'{SPECIAL_CHAR}incr'\n    new_deps = {\n        k.dst_key: message[k.src_key]\n        for k in self._dependencies\n        if k.src_key in message\n    }\n    incr_num = 0\n    if new_deps:\n        with redis_conn.pipeline() as p:\n            p.multi()\n            p.hset(dep_key, mapping=new_deps)  # type: ignore\n            p.incrby(incr_key, len(new_deps))\n            _, incr_num = p.execute()\n    if self._historical_dependencies:\n        self.send_historical_deps(message_id, message, pipeline)\n    if incr_num == self._num_dependencies:\n        dependencies = redis_conn.hgetall(dep_key)\n        for h in self._historical_dependencies:\n            dependencies[h.dst_key] = []\n            for i in range(h.history_length):\n                dep_value = dependencies.pop(\n                    f'{h.dst_key}{SPECIAL_CHAR}{i}', None)\n                dependencies[h.dst_key].append(\n                    decode_value(dep_value\n                                 ) if dep_value is not None else dep_value)\n            dependencies[h.dst_key] = encode_value(dependencies[h.dst_key])\n        # tutaj by\u0142a transakcja\n        pipeline.delete(dep_key, incr_key)\n        return {\n            self.output_stream_name: {\n                MSG_ID_FIELD: message_id_enc,\n                **dependencies\n            }\n        }\n    return {}\n</code></pre>"},{"location":"reference/consumers/dependency_resolver.html#pybrook.consumers.dependency_resolver.DependencyResolver.send_historical_deps","title":"<code>send_historical_deps(message_id, message, pipeline)</code>","text":"Source code in <code>pybrook/consumers/dependency_resolver.py</code> <pre><code>def send_historical_deps(self, message_id: str, message: Dict[str, str],\n                         pipeline: redis.client.Pipeline):\n    historical_deps = [(k.dst_key, message[k.src_key], k.history_length)\n                       for k in self._historical_dependencies\n                       if k.src_key in message]\n    if historical_deps:\n        vehicle_id, vehicle_message_id = message_id.rsplit(SPECIAL_CHAR,\n                                                           maxsplit=1)\n        dependency_map_key_base = self.dependency_map_key(vehicle_id\n                                                          + SPECIAL_CHAR)\n        for dst_key, value, history_length in historical_deps:\n            id_in_deps = history_length\n            future_vehicle_message_id = int(vehicle_message_id)\n            while id_in_deps &gt; 0:\n                id_in_deps -= 1\n                future_vehicle_message_id += 1\n                pipeline.hset(\n                    f'{dependency_map_key_base}{future_vehicle_message_id}',\n                    f'{dst_key}{SPECIAL_CHAR}{id_in_deps}', value)\n</code></pre>"},{"location":"reference/consumers/field_generator.html","title":"field_generator","text":""},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.AnyRedis","title":"<code>AnyRedis = Union[aioredis.Redis, redis.Redis]</code>  <code>module-attribute</code>","text":""},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.AsyncFieldGenerator","title":"<code>AsyncFieldGenerator</code>","text":"<p>         Bases: <code>AsyncStreamConsumer</code>, <code>BaseFieldGenerator</code></p> Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>class AsyncFieldGenerator(AsyncStreamConsumer, BaseFieldGenerator):\n    async def process_message_async(\n            self, stream_name: str, message: Dict[str, str], *,\n            redis_conn: aioredis.Redis,\n            pipeline: aioredis.client.Pipeline) -&gt; Dict[str, Dict[str, str]]:\n        message = decode_stream_message(message)\n        message_id = message.pop(MSG_ID_FIELD)\n        try:\n            dependencies = self.dep_model(**message).dict()\n        except Exception:\n            raise ValueError(message)\n        value = await self.call_generator(dependencies, redis_conn)\n        return {\n            self.output_stream_name:\n            encode_stream_message({\n                MSG_ID_FIELD: message_id,\n                self.field_name: value\n            })\n        }\n</code></pre>"},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.AsyncFieldGenerator.process_message_async","title":"<code>process_message_async(stream_name, message, *, redis_conn, pipeline)</code>  <code>async</code>","text":"Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>async def process_message_async(\n        self, stream_name: str, message: Dict[str, str], *,\n        redis_conn: aioredis.Redis,\n        pipeline: aioredis.client.Pipeline) -&gt; Dict[str, Dict[str, str]]:\n    message = decode_stream_message(message)\n    message_id = message.pop(MSG_ID_FIELD)\n    try:\n        dependencies = self.dep_model(**message).dict()\n    except Exception:\n        raise ValueError(message)\n    value = await self.call_generator(dependencies, redis_conn)\n    return {\n        self.output_stream_name:\n        encode_stream_message({\n            MSG_ID_FIELD: message_id,\n            self.field_name: value\n        })\n    }\n</code></pre>"},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator","title":"<code>BaseFieldGenerator</code>","text":"<p>         Bases: <code>BaseStreamConsumer</code></p> Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>class BaseFieldGenerator(BaseStreamConsumer):\n    @dataclasses.dataclass\n    class Dep:  # noqa: WPS431\n        name: str\n        value_type: Type\n\n    def __init__(self,\n                 *,\n                 generator: Callable,\n                 redis_url: str,\n                 field_name: str,\n                 namespace: str = ARTIFICIAL_NAMESPACE,\n                 dependency_stream: str,\n                 dependencies: List[Dep],\n                 redis_deps: List[str] = None,\n                 read_chunk_length: int = 200,\n                 **kwargs):\n        self.generator = generator\n        self.dependencies = dependencies\n        self.field_name = field_name\n        self.redis_deps = redis_deps or []\n        self.output_stream_name = f'{SPECIAL_CHAR}{namespace}{SPECIAL_CHAR}{field_name}'\n        pydantic_fields = {\n            dep.name: (dep.value_type, pydantic.Field())\n            for dep in dependencies\n        }\n        self.dep_model: Type[pydantic.BaseModel] = pydantic.create_model(\n            field_name + 'Model',\n            **pydantic_fields  # type: ignore\n        )\n\n        super().__init__(redis_url=redis_url,\n                         use_thread_executor=True,\n                         consumer_group_name=f'{field_name}{SPECIAL_CHAR}fg',\n                         input_streams=[dependency_stream],\n                         read_chunk_length=read_chunk_length,\n                         **kwargs)\n\n    def __repr__(self):\n        return f'&lt;{self.__class__.__name__} input_streams={self.input_streams}&gt;'\n\n    def call_generator(self, dependencies, redis_conn: AnyRedis):\n        if self.redis_deps:\n            return self.generator(**dependencies,\n                                  **{k: redis_conn\n                                     for k in self.redis_deps})\n        return self.generator(**dependencies)\n</code></pre>"},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.dep_model","title":"<code>dep_model: Type[pydantic.BaseModel] = pydantic.create_model(field_name + 'Model', None=pydantic_fields)</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.dependencies","title":"<code>dependencies = dependencies</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.field_name","title":"<code>field_name = field_name</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.generator","title":"<code>generator = generator</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.output_stream_name","title":"<code>output_stream_name = f'{SPECIAL_CHAR}{namespace}{SPECIAL_CHAR}{field_name}'</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.redis_deps","title":"<code>redis_deps = redis_deps or []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.Dep","title":"<code>Dep</code>  <code>dataclass</code>","text":"Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>@dataclasses.dataclass\nclass Dep:  # noqa: WPS431\n    name: str\n    value_type: Type\n</code></pre>"},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.Dep.name","title":"<code>name: str</code>  <code>class-attribute</code>","text":""},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.Dep.value_type","title":"<code>value_type: Type</code>  <code>class-attribute</code>","text":""},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.__init__","title":"<code>__init__(*, generator, redis_url, field_name, namespace=ARTIFICIAL_NAMESPACE, dependency_stream, dependencies, redis_deps=None, read_chunk_length=200, **kwargs)</code>","text":"Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>def __init__(self,\n             *,\n             generator: Callable,\n             redis_url: str,\n             field_name: str,\n             namespace: str = ARTIFICIAL_NAMESPACE,\n             dependency_stream: str,\n             dependencies: List[Dep],\n             redis_deps: List[str] = None,\n             read_chunk_length: int = 200,\n             **kwargs):\n    self.generator = generator\n    self.dependencies = dependencies\n    self.field_name = field_name\n    self.redis_deps = redis_deps or []\n    self.output_stream_name = f'{SPECIAL_CHAR}{namespace}{SPECIAL_CHAR}{field_name}'\n    pydantic_fields = {\n        dep.name: (dep.value_type, pydantic.Field())\n        for dep in dependencies\n    }\n    self.dep_model: Type[pydantic.BaseModel] = pydantic.create_model(\n        field_name + 'Model',\n        **pydantic_fields  # type: ignore\n    )\n\n    super().__init__(redis_url=redis_url,\n                     use_thread_executor=True,\n                     consumer_group_name=f'{field_name}{SPECIAL_CHAR}fg',\n                     input_streams=[dependency_stream],\n                     read_chunk_length=read_chunk_length,\n                     **kwargs)\n</code></pre>"},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>def __repr__(self):\n    return f'&lt;{self.__class__.__name__} input_streams={self.input_streams}&gt;'\n</code></pre>"},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.BaseFieldGenerator.call_generator","title":"<code>call_generator(dependencies, redis_conn)</code>","text":"Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>def call_generator(self, dependencies, redis_conn: AnyRedis):\n    if self.redis_deps:\n        return self.generator(**dependencies,\n                              **{k: redis_conn\n                                 for k in self.redis_deps})\n    return self.generator(**dependencies)\n</code></pre>"},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.SyncFieldGenerator","title":"<code>SyncFieldGenerator</code>","text":"<p>         Bases: <code>SyncStreamConsumer</code>, <code>BaseFieldGenerator</code></p> Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>class SyncFieldGenerator(SyncStreamConsumer, BaseFieldGenerator):\n    def process_message_sync(\n            self, stream_name: str, message: Dict[str, str], *,\n            redis_conn: redis.Redis,\n            pipeline: redis.client.Pipeline) -&gt; Dict[str, Dict[str, str]]:\n        message = decode_stream_message(message)\n        message_id = message.pop(MSG_ID_FIELD)\n        try:\n            dependencies = self.dep_model(**message).dict()\n        except Exception:\n            raise ValueError(message)\n        value = self.call_generator(dependencies, redis_conn)\n        return {\n            self.output_stream_name:\n            encode_stream_message({\n                MSG_ID_FIELD: message_id,\n                self.field_name: value\n            })\n        }\n</code></pre>"},{"location":"reference/consumers/field_generator.html#pybrook.consumers.field_generator.SyncFieldGenerator.process_message_sync","title":"<code>process_message_sync(stream_name, message, *, redis_conn, pipeline)</code>","text":"Source code in <code>pybrook/consumers/field_generator.py</code> <pre><code>def process_message_sync(\n        self, stream_name: str, message: Dict[str, str], *,\n        redis_conn: redis.Redis,\n        pipeline: redis.client.Pipeline) -&gt; Dict[str, Dict[str, str]]:\n    message = decode_stream_message(message)\n    message_id = message.pop(MSG_ID_FIELD)\n    try:\n        dependencies = self.dep_model(**message).dict()\n    except Exception:\n        raise ValueError(message)\n    value = self.call_generator(dependencies, redis_conn)\n    return {\n        self.output_stream_name:\n        encode_stream_message({\n            MSG_ID_FIELD: message_id,\n            self.field_name: value\n        })\n    }\n</code></pre>"},{"location":"reference/consumers/splitter.html","title":"splitter","text":""},{"location":"reference/consumers/splitter.html#pybrook.consumers.splitter.AsyncSplitter","title":"<code>AsyncSplitter</code>","text":"<p>         Bases: <code>AsyncStreamConsumer</code>, <code>BaseSplitter</code></p> Source code in <code>pybrook/consumers/splitter.py</code> <pre><code>class AsyncSplitter(AsyncStreamConsumer, BaseSplitter):\n    async def process_message_async(\n            self, stream_name: str, message: Dict[str, str], *,\n            redis_conn: aioredis.Redis,\n            pipeline: aioredis.client.Pipeline) -&gt; Dict[str, Dict[str, str]]:\n        obj_id = decode_value(message[self.object_id_field])\n        obj_msg_id = await redis_conn.incr(self.get_obj_msg_id_key(obj_id))\n        return self.split_msg(message, obj_id=obj_id, obj_msg_id=obj_msg_id)\n</code></pre>"},{"location":"reference/consumers/splitter.html#pybrook.consumers.splitter.AsyncSplitter.process_message_async","title":"<code>process_message_async(stream_name, message, *, redis_conn, pipeline)</code>  <code>async</code>","text":"Source code in <code>pybrook/consumers/splitter.py</code> <pre><code>async def process_message_async(\n        self, stream_name: str, message: Dict[str, str], *,\n        redis_conn: aioredis.Redis,\n        pipeline: aioredis.client.Pipeline) -&gt; Dict[str, Dict[str, str]]:\n    obj_id = decode_value(message[self.object_id_field])\n    obj_msg_id = await redis_conn.incr(self.get_obj_msg_id_key(obj_id))\n    return self.split_msg(message, obj_id=obj_id, obj_msg_id=obj_msg_id)\n</code></pre>"},{"location":"reference/consumers/splitter.html#pybrook.consumers.splitter.BaseSplitter","title":"<code>BaseSplitter</code>","text":"<p>         Bases: <code>BaseStreamConsumer</code></p> Source code in <code>pybrook/consumers/splitter.py</code> <pre><code>class BaseSplitter(BaseStreamConsumer):\n    def __init__(self,\n                 *,\n                 redis_url: str,\n                 consumer_group_name: str,\n                 input_streams: Iterable[str],\n                 object_id_field: str,\n                 namespace: str,\n                 read_chunk_length: int = 100,\n                 **kwargs):\n        self.namespace: str = namespace\n        self.object_id_field: str = object_id_field\n        super().__init__(redis_url=redis_url,\n                         consumer_group_name=consumer_group_name,\n                         input_streams=input_streams,\n                         read_chunk_length=read_chunk_length,\n                         **kwargs)\n\n    def split_msg(self, message: Dict[str, str], *, obj_id: str,\n                  obj_msg_id: str):\n        message_id = f'{obj_id}{SPECIAL_CHAR}{obj_msg_id}'\n        return {\n            f'{SPECIAL_CHAR}{self.namespace}{SPECIAL_CHAR}split': {\n                MSG_ID_FIELD: encode_value(message_id),\n                **message\n            }\n        }\n\n    def get_obj_msg_id_key(self, obj_id: str):\n        return f'{SPECIAL_CHAR}id{SPECIAL_CHAR}{obj_id}'\n</code></pre>"},{"location":"reference/consumers/splitter.html#pybrook.consumers.splitter.BaseSplitter.namespace","title":"<code>namespace: str = namespace</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/splitter.html#pybrook.consumers.splitter.BaseSplitter.object_id_field","title":"<code>object_id_field: str = object_id_field</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/splitter.html#pybrook.consumers.splitter.BaseSplitter.__init__","title":"<code>__init__(*, redis_url, consumer_group_name, input_streams, object_id_field, namespace, read_chunk_length=100, **kwargs)</code>","text":"Source code in <code>pybrook/consumers/splitter.py</code> <pre><code>def __init__(self,\n             *,\n             redis_url: str,\n             consumer_group_name: str,\n             input_streams: Iterable[str],\n             object_id_field: str,\n             namespace: str,\n             read_chunk_length: int = 100,\n             **kwargs):\n    self.namespace: str = namespace\n    self.object_id_field: str = object_id_field\n    super().__init__(redis_url=redis_url,\n                     consumer_group_name=consumer_group_name,\n                     input_streams=input_streams,\n                     read_chunk_length=read_chunk_length,\n                     **kwargs)\n</code></pre>"},{"location":"reference/consumers/splitter.html#pybrook.consumers.splitter.BaseSplitter.get_obj_msg_id_key","title":"<code>get_obj_msg_id_key(obj_id)</code>","text":"Source code in <code>pybrook/consumers/splitter.py</code> <pre><code>def get_obj_msg_id_key(self, obj_id: str):\n    return f'{SPECIAL_CHAR}id{SPECIAL_CHAR}{obj_id}'\n</code></pre>"},{"location":"reference/consumers/splitter.html#pybrook.consumers.splitter.BaseSplitter.split_msg","title":"<code>split_msg(message, *, obj_id, obj_msg_id)</code>","text":"Source code in <code>pybrook/consumers/splitter.py</code> <pre><code>def split_msg(self, message: Dict[str, str], *, obj_id: str,\n              obj_msg_id: str):\n    message_id = f'{obj_id}{SPECIAL_CHAR}{obj_msg_id}'\n    return {\n        f'{SPECIAL_CHAR}{self.namespace}{SPECIAL_CHAR}split': {\n            MSG_ID_FIELD: encode_value(message_id),\n            **message\n        }\n    }\n</code></pre>"},{"location":"reference/consumers/splitter.html#pybrook.consumers.splitter.GearsSplitter","title":"<code>GearsSplitter</code>","text":"<p>         Bases: <code>GearsStreamConsumer</code>, <code>BaseSplitter</code></p> Source code in <code>pybrook/consumers/splitter.py</code> <pre><code>class GearsSplitter(GearsStreamConsumer, BaseSplitter):\n    def register_readers(self, execute: Callable[..., Any],\n                         gears_builder: Any):  # pragma: no cover\n        import json\n        from itertools import chain\n\n        def process_message(msg):  # noqa: WPS430\n            message = msg[\"value\"]\n            obj_id = json.loads(message[self.object_id_field])\n            msg_id_key = f'{SPECIAL_CHAR}id{SPECIAL_CHAR}{obj_id}'\n            obj_msg_id = execute(\"INCR\", msg_id_key)\n            out_stream = f'{SPECIAL_CHAR}{self.namespace}{SPECIAL_CHAR}split'\n            message[MSG_ID_FIELD] = f'\"{obj_id}:{obj_msg_id}\"'\n            execute(\"XADD\", out_stream, '*', *chain(*message.items()))\n\n        for s in self._input_streams:\n            gears_builder(\"StreamReader\").foreach(process_message).register(\n                s, trimStream=False, mode=\"sync\", batch=1000, duration=1)\n\n    def register_builder(self, conn: redis.Redis):\n        scope = {\n            name: value\n            for name, value in globals().items()\n            if type(value) in {int, list, str, float}  # noqa: WPS516\n            and not name.startswith('__')\n        }\n        context = {**scope, 'ctx': self.__dict__}\n        registration_fun_code = dedent(inspect.getsource(\n            self.register_readers)).split('@staticmethod', maxsplit=1)[-1]\n        context_dumps = str(pickle.dumps(context))\n        cmd = f'import pickle\\nfrom typing import *\\n{registration_fun_code}\\n' \\\n              f'locals().update(pickle.loads({context_dumps}))\\n' \\\n              f'register_readers(self=type(\"{self.__class__.__name__}\", (), ctx), execute=execute, gears_builder=GearsBuilder)'''\n        print(cmd)\n        out = conn.execute_command('RG.PYEXECUTE', cmd)\n        logger.info(f'Registered Redis Gears Reader: \\n{cmd}\\n{out}')\n</code></pre>"},{"location":"reference/consumers/splitter.html#pybrook.consumers.splitter.GearsSplitter.register_builder","title":"<code>register_builder(conn)</code>","text":"Source code in <code>pybrook/consumers/splitter.py</code> <pre><code>def register_builder(self, conn: redis.Redis):\n    scope = {\n        name: value\n        for name, value in globals().items()\n        if type(value) in {int, list, str, float}  # noqa: WPS516\n        and not name.startswith('__')\n    }\n    context = {**scope, 'ctx': self.__dict__}\n    registration_fun_code = dedent(inspect.getsource(\n        self.register_readers)).split('@staticmethod', maxsplit=1)[-1]\n    context_dumps = str(pickle.dumps(context))\n    cmd = f'import pickle\\nfrom typing import *\\n{registration_fun_code}\\n' \\\n          f'locals().update(pickle.loads({context_dumps}))\\n' \\\n          f'register_readers(self=type(\"{self.__class__.__name__}\", (), ctx), execute=execute, gears_builder=GearsBuilder)'''\n    print(cmd)\n    out = conn.execute_command('RG.PYEXECUTE', cmd)\n    logger.info(f'Registered Redis Gears Reader: \\n{cmd}\\n{out}')\n</code></pre>"},{"location":"reference/consumers/splitter.html#pybrook.consumers.splitter.GearsSplitter.register_readers","title":"<code>register_readers(execute, gears_builder)</code>","text":"Source code in <code>pybrook/consumers/splitter.py</code> <pre><code>def register_readers(self, execute: Callable[..., Any],\n                     gears_builder: Any):  # pragma: no cover\n    import json\n    from itertools import chain\n\n    def process_message(msg):  # noqa: WPS430\n        message = msg[\"value\"]\n        obj_id = json.loads(message[self.object_id_field])\n        msg_id_key = f'{SPECIAL_CHAR}id{SPECIAL_CHAR}{obj_id}'\n        obj_msg_id = execute(\"INCR\", msg_id_key)\n        out_stream = f'{SPECIAL_CHAR}{self.namespace}{SPECIAL_CHAR}split'\n        message[MSG_ID_FIELD] = f'\"{obj_id}:{obj_msg_id}\"'\n        execute(\"XADD\", out_stream, '*', *chain(*message.items()))\n\n    for s in self._input_streams:\n        gears_builder(\"StreamReader\").foreach(process_message).register(\n            s, trimStream=False, mode=\"sync\", batch=1000, duration=1)\n</code></pre>"},{"location":"reference/consumers/splitter.html#pybrook.consumers.splitter.Splitter","title":"<code>Splitter</code>","text":"<p>         Bases: <code>GearsSplitter</code>, <code>AsyncSplitter</code>, <code>SyncSplitter</code>, <code>BaseSplitter</code></p> <p>Splitter.</p> Source code in <code>pybrook/consumers/splitter.py</code> <pre><code>class Splitter(  # noqa: WPS215\n        GearsSplitter, AsyncSplitter, SyncSplitter, BaseSplitter):\n\"\"\"Splitter.\"\"\"\n</code></pre>"},{"location":"reference/consumers/splitter.html#pybrook.consumers.splitter.SyncSplitter","title":"<code>SyncSplitter</code>","text":"<p>         Bases: <code>SyncStreamConsumer</code>, <code>BaseSplitter</code></p> Source code in <code>pybrook/consumers/splitter.py</code> <pre><code>class SyncSplitter(SyncStreamConsumer, BaseSplitter):\n    def process_message_sync(\n            self, stream_name: str, message: Dict[str, str], *,\n            redis_conn: redis.Redis,\n            pipeline: redis.client.Pipeline) -&gt; Dict[str, Dict[str, str]]:\n        obj_id = decode_value(message[self.object_id_field])\n        obj_msg_id = str(redis_conn.incr(self.get_obj_msg_id_key(obj_id)))\n        return self.split_msg(message, obj_id=obj_id, obj_msg_id=obj_msg_id)\n</code></pre>"},{"location":"reference/consumers/splitter.html#pybrook.consumers.splitter.SyncSplitter.process_message_sync","title":"<code>process_message_sync(stream_name, message, *, redis_conn, pipeline)</code>","text":"Source code in <code>pybrook/consumers/splitter.py</code> <pre><code>def process_message_sync(\n        self, stream_name: str, message: Dict[str, str], *,\n        redis_conn: redis.Redis,\n        pipeline: redis.client.Pipeline) -&gt; Dict[str, Dict[str, str]]:\n    obj_id = decode_value(message[self.object_id_field])\n    obj_msg_id = str(redis_conn.incr(self.get_obj_msg_id_key(obj_id)))\n    return self.split_msg(message, obj_id=obj_id, obj_msg_id=obj_msg_id)\n</code></pre>"},{"location":"reference/consumers/worker.html","title":"worker","text":""},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.DEFAULT_PROCESSES_NUM","title":"<code>DEFAULT_PROCESSES_NUM = multiprocessing.cpu_count()</code>  <code>module-attribute</code>","text":""},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.ConsumerConfig","title":"<code>ConsumerConfig</code>  <code>dataclass</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>@dataclasses.dataclass\nclass ConsumerConfig:\n    workers: int = DEFAULT_WORKERS\n</code></pre>"},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.ConsumerConfig.workers","title":"<code>workers: int = DEFAULT_WORKERS</code>  <code>class-attribute</code>","text":""},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.Worker","title":"<code>Worker</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>class Worker:\n    def __init__(self, consumer: BaseStreamConsumer):\n        self._consumer = consumer\n\n    def run(self, *, processes_num: int = DEFAULT_PROCESSES_NUM):\n        if isinstance(self._consumer, SyncStreamConsumer):\n            return self._spawn_sync(processes_num=processes_num)\n        elif isinstance(self._consumer, AsyncStreamConsumer):\n            return self._spawn_async(processes_num=processes_num)\n        raise NotImplementedError(self._consumer)\n\n    def _spawn_sync(self,\n                    processes_num: int) -&gt; Iterable[multiprocessing.Process]:\n        return self._spawn(\n            target=self._consumer.run_sync,  # type: ignore\n            processes_num=processes_num)\n\n    def _async_wrapper(self):\n        policy = uvloop.EventLoopPolicy()\n        asyncio.set_event_loop_policy(policy)\n        asyncio.set_event_loop(policy.new_event_loop())\n        try:\n            asyncio.get_event_loop().run_until_complete(\n                self._consumer.run_async())\n        except KeyboardInterrupt:\n            ...\n        except asyncio.CancelledError:\n            ...  # This is fine, shouldn't break anything\n\n    def _spawn_async(self, *,\n                     processes_num: int) -&gt; Iterable[multiprocessing.Process]:\n        return self._spawn(target=self._async_wrapper,\n                           processes_num=processes_num)\n\n    def _spawn(\n            self,\n            *,\n            target: Callable,\n            processes_num: int,\n            args: Tuple[Any, ...] = (),\n    ) -&gt; Iterable[multiprocessing.Process]:\n        processes = []\n        self._consumer.register_consumer()\n\n        for _ in range(processes_num):\n            proc = multiprocessing.Process(target=target, args=args)\n            proc.start()\n            processes.append(proc)\n        logger.info(\n            f'Spawned {processes_num} processes for {type(self._consumer).__name__}'\n        )\n        return processes\n</code></pre>"},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.Worker._consumer","title":"<code>_consumer = consumer</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.Worker.__init__","title":"<code>__init__(consumer)</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def __init__(self, consumer: BaseStreamConsumer):\n    self._consumer = consumer\n</code></pre>"},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.Worker._async_wrapper","title":"<code>_async_wrapper()</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def _async_wrapper(self):\n    policy = uvloop.EventLoopPolicy()\n    asyncio.set_event_loop_policy(policy)\n    asyncio.set_event_loop(policy.new_event_loop())\n    try:\n        asyncio.get_event_loop().run_until_complete(\n            self._consumer.run_async())\n    except KeyboardInterrupt:\n        ...\n    except asyncio.CancelledError:\n        ...  # This is fine, shouldn't break anything\n</code></pre>"},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.Worker._spawn","title":"<code>_spawn(*, target, processes_num, args=())</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def _spawn(\n        self,\n        *,\n        target: Callable,\n        processes_num: int,\n        args: Tuple[Any, ...] = (),\n) -&gt; Iterable[multiprocessing.Process]:\n    processes = []\n    self._consumer.register_consumer()\n\n    for _ in range(processes_num):\n        proc = multiprocessing.Process(target=target, args=args)\n        proc.start()\n        processes.append(proc)\n    logger.info(\n        f'Spawned {processes_num} processes for {type(self._consumer).__name__}'\n    )\n    return processes\n</code></pre>"},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.Worker._spawn_async","title":"<code>_spawn_async(*, processes_num)</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def _spawn_async(self, *,\n                 processes_num: int) -&gt; Iterable[multiprocessing.Process]:\n    return self._spawn(target=self._async_wrapper,\n                       processes_num=processes_num)\n</code></pre>"},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.Worker._spawn_sync","title":"<code>_spawn_sync(processes_num)</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def _spawn_sync(self,\n                processes_num: int) -&gt; Iterable[multiprocessing.Process]:\n    return self._spawn(\n        target=self._consumer.run_sync,  # type: ignore\n        processes_num=processes_num)\n</code></pre>"},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.Worker.run","title":"<code>run(*, processes_num=DEFAULT_PROCESSES_NUM)</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def run(self, *, processes_num: int = DEFAULT_PROCESSES_NUM):\n    if isinstance(self._consumer, SyncStreamConsumer):\n        return self._spawn_sync(processes_num=processes_num)\n    elif isinstance(self._consumer, AsyncStreamConsumer):\n        return self._spawn_async(processes_num=processes_num)\n    raise NotImplementedError(self._consumer)\n</code></pre>"},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.WorkerManager","title":"<code>WorkerManager</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>class WorkerManager:\n    def __init__(self,\n                 consumers: Iterable[BaseStreamConsumer],\n                 config: Dict[str, ConsumerConfig] = None,\n                 enable_gears: bool = True):\n        self.consumers = consumers\n        self.config = config or {}\n        self.redis_urls: Set[str] = {c.redis_url for c in consumers}\n        self.gears_consumers: List[GearsStreamConsumer] = [\n            c for c in consumers if enable_gears and isinstance(c, GearsStreamConsumer)\n        ]\n        self.regular_consumers: List[BaseStreamConsumer] = [\n            c for c in consumers if not enable_gears or not isinstance(c, GearsStreamConsumer)\n        ]\n        self.processes: List[multiprocessing.Process] = []\n        self._kill_on_terminate = False\n\n    def terminate(self):\n        if self._kill_on_terminate:\n            for p in self.processes:\n                p.kill()\n            return\n        for p in self.processes:  # noqa: WPS440\n            p.terminate()\n        self._kill_on_terminate = True\n\n    def run(self):\n        if self.processes:\n            raise RuntimeError('Already running!')\n        signal.signal(signal.SIGINT, lambda *args: self.terminate)\n        signal.signal(signal.SIGTERM, lambda *args: self.terminate)\n\n        self.spawn_workers()\n\n        for redis_url in self.redis_urls:\n            redis_conn = redis.from_url(redis_url,\n                                        decode_responses=True,\n                                        encoding='utf-8')\n            self.acquire_gears_registration_lock(redis_conn)\n            ids = [\n                r[1]\n                for r in redis_conn.execute_command('RG.DUMPREGISTRATIONS')\n            ]\n            for i in ids:\n                redis_conn.execute_command('RG.UNREGISTER', i)\n            for consumer in self.gears_consumers:\n                consumer.register_builder(redis_conn)\n            redis_conn.delete('RG.REGISTERLOCK')\n        for proc in self.processes:\n            try:\n                proc.join()\n            except KeyboardInterrupt:\n                ...\n        self.processes = []\n\n    def spawn_workers(self):\n        for c in self.regular_consumers:\n            consumer_config = self.config.get(c.consumer_group_name,\n                                              ConsumerConfig())\n            logger.info(f'Spawning worker for {c}...')\n            w = Worker(c)\n            procs = w.run(processes_num=consumer_config.workers)\n            self.processes.extend(procs)\n\n    def acquire_gears_registration_lock(self, redis_conn: redis.Redis):\n        with redis_conn.pipeline() as p:\n            p.watch('RG.REGISTERLOCK')\n            if p.exists('RG.REGISTERLOCK'):\n                raise RuntimeError(\n                    'Try again later, RG registration is locked, possibly by another instance'\n                )\n            p.multi()\n            p.set('RG.REGISTERLOCK', '1')\n            p.expire('RG.REGISTERLOCK', 5)\n            p.execute(raise_on_error=True)\n</code></pre>"},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.WorkerManager._kill_on_terminate","title":"<code>_kill_on_terminate = False</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.WorkerManager.config","title":"<code>config = config or {}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.WorkerManager.consumers","title":"<code>consumers = consumers</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.WorkerManager.gears_consumers","title":"<code>gears_consumers: List[GearsStreamConsumer] = [c for c in consumers if enable_gears and isinstance(c, GearsStreamConsumer)]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.WorkerManager.processes","title":"<code>processes: List[multiprocessing.Process] = []</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.WorkerManager.redis_urls","title":"<code>redis_urls: Set[str] = {c.redis_url for c in consumers}</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.WorkerManager.regular_consumers","title":"<code>regular_consumers: List[BaseStreamConsumer] = [c for c in consumers if not enable_gears or not isinstance(c, GearsStreamConsumer)]</code>  <code>instance-attribute</code>","text":""},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.WorkerManager.__init__","title":"<code>__init__(consumers, config=None, enable_gears=True)</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def __init__(self,\n             consumers: Iterable[BaseStreamConsumer],\n             config: Dict[str, ConsumerConfig] = None,\n             enable_gears: bool = True):\n    self.consumers = consumers\n    self.config = config or {}\n    self.redis_urls: Set[str] = {c.redis_url for c in consumers}\n    self.gears_consumers: List[GearsStreamConsumer] = [\n        c for c in consumers if enable_gears and isinstance(c, GearsStreamConsumer)\n    ]\n    self.regular_consumers: List[BaseStreamConsumer] = [\n        c for c in consumers if not enable_gears or not isinstance(c, GearsStreamConsumer)\n    ]\n    self.processes: List[multiprocessing.Process] = []\n    self._kill_on_terminate = False\n</code></pre>"},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.WorkerManager.acquire_gears_registration_lock","title":"<code>acquire_gears_registration_lock(redis_conn)</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def acquire_gears_registration_lock(self, redis_conn: redis.Redis):\n    with redis_conn.pipeline() as p:\n        p.watch('RG.REGISTERLOCK')\n        if p.exists('RG.REGISTERLOCK'):\n            raise RuntimeError(\n                'Try again later, RG registration is locked, possibly by another instance'\n            )\n        p.multi()\n        p.set('RG.REGISTERLOCK', '1')\n        p.expire('RG.REGISTERLOCK', 5)\n        p.execute(raise_on_error=True)\n</code></pre>"},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.WorkerManager.run","title":"<code>run()</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def run(self):\n    if self.processes:\n        raise RuntimeError('Already running!')\n    signal.signal(signal.SIGINT, lambda *args: self.terminate)\n    signal.signal(signal.SIGTERM, lambda *args: self.terminate)\n\n    self.spawn_workers()\n\n    for redis_url in self.redis_urls:\n        redis_conn = redis.from_url(redis_url,\n                                    decode_responses=True,\n                                    encoding='utf-8')\n        self.acquire_gears_registration_lock(redis_conn)\n        ids = [\n            r[1]\n            for r in redis_conn.execute_command('RG.DUMPREGISTRATIONS')\n        ]\n        for i in ids:\n            redis_conn.execute_command('RG.UNREGISTER', i)\n        for consumer in self.gears_consumers:\n            consumer.register_builder(redis_conn)\n        redis_conn.delete('RG.REGISTERLOCK')\n    for proc in self.processes:\n        try:\n            proc.join()\n        except KeyboardInterrupt:\n            ...\n    self.processes = []\n</code></pre>"},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.WorkerManager.spawn_workers","title":"<code>spawn_workers()</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def spawn_workers(self):\n    for c in self.regular_consumers:\n        consumer_config = self.config.get(c.consumer_group_name,\n                                          ConsumerConfig())\n        logger.info(f'Spawning worker for {c}...')\n        w = Worker(c)\n        procs = w.run(processes_num=consumer_config.workers)\n        self.processes.extend(procs)\n</code></pre>"},{"location":"reference/consumers/worker.html#pybrook.consumers.worker.WorkerManager.terminate","title":"<code>terminate()</code>","text":"Source code in <code>pybrook/consumers/worker.py</code> <pre><code>def terminate(self):\n    if self._kill_on_terminate:\n        for p in self.processes:\n            p.kill()\n        return\n    for p in self.processes:  # noqa: WPS440\n        p.terminate()\n    self._kill_on_terminate = True\n</code></pre>"}]}